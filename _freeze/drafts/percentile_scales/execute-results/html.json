{
  "hash": "cd483fa5973305c9c52e2be3f6296dc4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"A few remarks on percentile scales\"\nauthor: \"Michał Wypych\"\n---\n\n\nSo this\n\nWhat to show in the post:\n\n-   how marginal distribution with percentiles looks like - its uniform!\n\n-   How changing the original distribution changes the percentile distribution\n\n-   How spacing between percentiles looks like for a gaussian original distribution - more packed around 50th percentile\n\n-   How much variability in time might we expect around the center and tails due to the above\n\n-   How correlations with percentile scales might look like\n\nBelow is the setup chunk with some functions for plots and loaded packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nDołączanie pakietu: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNastępujące obiekty zostały zakryte z 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNastępujące obiekty zostały zakryte z 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(showtext)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nŁadowanie wymaganego pakietu: sysfonts\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nŁadowanie wymaganego pakietu: showtextdb\n```\n\n\n:::\n\n```{.r .cell-code}\nfont_add_google(\"Lato\")\nfont_add_google(\"Ubuntu\")\nshowtext_auto()\n\n\ncol_main <- c(\"darkred\", \"firebrick3\", \"coral1\", \"salmon\",\"rosybrown3\",\"palevioletred1\", \"plum4\", \"purple2\",\"springgreen2\", \"seagreen\",\"skyblue\", \"turquoise4\", \"steelblue4\", \"royalblue3\", \"slateblue4\", \"navyblue\" )\n\n\n\nmy_theme <- function() {\n  #requires Lato and Ubuntu fonts\n  theme_minimal(base_family = \"Lato\", base_size = 20) +\n    theme(panel.grid.minor = element_blank(),\n          plot.background = element_rect(fill = \"white\", color = NA),\n          plot.title = element_text(face = \"bold\", size = 30, family = \"Ubuntu\"),\n          plot.subtitle = element_text(size = 20),\n          axis.title = element_text(face = \"bold\"),\n          strip.text = element_text(face = \"bold\"),\n          strip.background = element_rect(fill = \"grey80\", color = NA),\n          legend.title = element_text(face = \"bold\"),\n          plot.title.position = \"plot\")\n}\n```\n:::\n\n\nFirst lets get some data in.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' lets start with some simulation\n\nN <- 1e4\nx <- rnorm(N)\n\nx_perc <- ntile(x, 100)\n```\n:::\n\n\n## looking at marginal distributions\n\n### changing original distribution\n\n## Spacing between percentiles\n\nOne thing that is often forgotten about the percentile scales is that there can be different spacings between various percentiles. Lets calculate the values for percentiles and then get differences between subsequent percentiles to look at this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_percentiles <- quantile(x, probs = seq(.01, 1, .01))\n\nx_df <- data.frame(x_percentiles) %>%\n  mutate(perc_lag = lag(x_percentiles),\n         difference_1 = x_percentiles - perc_lag)\n\nx_df %>%\n  drop_na() %>%\n  ggplot(aes(x = 2:100, y = difference_1)) +\n  geom_point(color = col_main[12]) +\n  labs(x = NULL, y = \"difference\") +\n  my_theme()\n```\n\n::: {.cell-output-display}\n![](percentile_scales_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nYou can see that the differences are quite large for the first few and last few percentiles and are pretty small for the rest. This is exactly what we would expect with a gaussian original distribution\n\nLets try to overlay the percentiles on the gaussian distribution we drew our data from\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(x) |>\n  ggplot(aes(x)) +\n  geom_density(color = col_main[13], linewidth = 2) +\n  geom_vline(data = x_df, aes(xintercept = x_percentiles), color = col_main[12]) +\n  labs(title = \"Spacing of percentiles\", subtitle = \"Original distribution (thick red line) has percentiles\\noverlayed as vertical lines (pink)\") +\n  my_theme()\n```\n\n::: {.cell-output-display}\n![](percentile_scales_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nYou can see how much of the distribution falls into 1st, 2nd or 99th percentile and how little falls into a single percentile in the middle of the distribution. It's actually fairly intuitive why this happens. The same number of people have to fall into each percentile and if there are few people at the tails of the distribution then we need to widen the range of the percentiles there to get enough people. The opposite is true for the peak of the distribution. There are a lot of people there so slim sliver of the distribution is enough to get quite a few people into the percentile. The fact that someone falls into low/high percentile doe\n\nThis also means that if some value increases over time from a very low percentile with a steady pace then we might expect first slow increases in percentiles, then rapid increases around the middle of the distribution and again slower increases as we are reaching the top. Lets try simulating that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' generate initial small x\n#' run a for loop in which we:\n#' - increase the value of x\n#' - record its percentile now and save it\n#' - store percentile for each step\n#' \n\nx_init <- min(x) #start with the lowest value in our distribution\nperc_progress <- c() #create a vector to store percentiles\nfor(i in 1:1000) { # max of 1000 steps\n  x_init <- x_init + .1 #increase our value by .1\n  perc_value <- min(x_percentiles[which(x_percentiles > x_init)]) # get the percentile value\n  percentile <- names(x_percentiles[which(x_percentiles == perc_value)]) # get the percentile name\n  perc_progress <- c(perc_progress, percentile) # we want to stop if we get too close to max value and there are still iterations left (otherwise the min() function breaks)\n  if (x_init >=(max(x) - .1)) {\n    break\n  }\n}\n\nperc_progress<- as.numeric(str_extract(perc_progress, \"[0-9]+\"))\n\ndata.frame(perc_progress) %>%\n  ggplot(aes(x = 1:length(perc_progress), y = perc_progress)) +\n  geom_line(color = col_main[12], linewidth = 2) +\n  labs(x = \"iteration\", y = \"percentile\") +\n  my_theme()\n```\n\n::: {.cell-output-display}\n![](percentile_scales_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nExactly what we would expect! First the change in percentiles is slow, then it speeds up and slows down in the right half of the plot. It takes us a long time to get out of the lowest percentiles but once we do we quickly get to the 50th and start changing more slowly form there on.\n\n### variability in percentiles\n\nOne significant consequence of how differences between subsequent percentiles vary is how much variability in percentiles can we expect with the same amount of variability on the original scale depending on where we start.\n\nThis is a common thing when infants gain weight. They might be gaining weight by some amount plus some random variations (lots of reasons here - some things in the diet, baby pooped/peed before being weighed etc.). In low or high percentiles we might expect this random variation in how much they gain weight to matter little. However in the middle it will make the variation in percentiles seem bigger. Again lets simulate some random variation around our distribution of x with 3 starting places: low (5th), middle (50th) and high percentile (95th).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_variability <- function(init_perc, sd_change) {\n  x_init <- x_percentiles[init_perc] #start with the lowest value in our distribution\nperc_progress <- c() #create a vector to store percentiles\nfor(i in 1:1000) { # max of 1000 steps\n  x_init <- x_init + rnorm(1, mean = 0, sd = sd_change) #increase our value by .1\n  perc_value <- min(x_percentiles[which(x_percentiles > x_init)]) # get the percentile value\n  percentile <- names(x_percentiles[which(x_percentiles == perc_value)]) # get the percentile name\n  perc_progress <- c(perc_progress, percentile) # we want to stop if we get too close to max value and there are still iterations left (otherwise the min() function breaks)\n  if (x_init >=(max(x) - .1) | x_init <= (min(x) + .1)) {\n    break\n  }\n}\n  perc_progress<- as.numeric(str_extract(perc_progress, \"[0-9]+\"))\n  return(perc_progress)\n}\n\n\nprog_low <- simulate_variability(5, .02)\nprog_mid <- simulate_variability(50, .02)\nprog_high <- simulate_variability(95, .02)\n\nprog_df <- data.frame(prog_low, prog_mid, prog_high) %>%\n  pivot_longer(cols = everything(), values_to = \"percentile\", names_to = \"condition\") %>%\n  mutate(condition = factor(condition, ordered = T, levels = c(\"prog_low\", \"prog_mid\", \"prog_high\")))\n\n\nprog_df %>%\n  ggplot(aes(x = 1:length(percentile)/3, y = percentile)) +\n  geom_line(color = col_main[12]) +\n  facet_wrap(~condition) +\n  labs(x = \"iteration\", y = \"percentile\") +\n  my_theme()\n```\n\n::: {.cell-output-display}\n![](percentile_scales_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nYou can see a lot more variability in the middle panel than in the left or right ones even though the changes on the original scale come from the same distribution.\n\nIn the above simulation we were in fact not creating any growth, just random variation from the original value (in order to simulate that we would need percentiles for each iteration) but assuming no strange growths that would not change the results a lot (rather than drawing a number from a distribution with mean 0 we would make the mean higher than 0 and still our expectation would be that a person in 50th percentile in time 1 should be on average in 50th percentile in time 2).\n\nThis means that when looking at percentiles e.g. weight gains of babies in low or high percentiles might seem much more stable than of those from the mid percentiles even if in fact they are very similar weight gains.\n\n## Correlations with percentiles\n\nThe last thing worth looking at when working with percentile scales are some unintuitive things about correlations on percentile scales.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- rnorm(N, .6*x)\n\ny_perc <- ntile(y, 100)\n\nd <- data.frame(x, y, x_perc, y_perc)\n```\n:::\n\n\nLets start by looking at a simple scatterplot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd |>\n  ggplot(aes(x = x, y = y)) +\n  geom_point(alpha = .3) +\n  labs(title = paste0(\"correlation = \",as.character(round(cor(x, y), 2)))) +\n  my_theme()\n```\n\n::: {.cell-output-display}\n![](percentile_scales_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nNow lets look at the percentiles:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd |>\n  ggplot(aes(x = x_perc, y = y_perc)) +\n  geom_point(alpha = .3) +\n  labs(title = paste0(\"correlation = \",as.character(round(cor(x_perc, y_perc), 2)))) +\n  my_theme()\n```\n\n::: {.cell-output-display}\n![](percentile_scales_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nlooks a loot more noisy right? But the correlation is pretty much the same. This can be pretty confusing and is actually sometimes done in those \"guess the correlation from the scatterplot\" games.\n\n**Do I want to add some transformations and how they affect correlations?**\n\nlets try some additional weirder stuff\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_moved <- x + .5\nx_m_perc <- ntile(x_moved, 100)\n\nplot(x_moved, y)\n```\n\n::: {.cell-output-display}\n![](percentile_scales_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx_scaled <- x^2\nx_s_perc <- ntile(x_scaled, 100)\n\ncor(x_s_perc, y_perc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.01078776\n```\n\n\n:::\n\n```{.r .cell-code}\ncor(x_scaled, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.009259721\n```\n\n\n:::\n:::\n",
    "supporting": [
      "percentile_scales_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}