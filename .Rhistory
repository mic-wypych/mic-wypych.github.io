test <- expand.grid(1:10,1:10)
View(test)
library(igraph)
x <- table(test)
x %*% t(x)
test <- matrix(rep('-', nrow*ncol), nrow = 10, ncol = 10)
test <- matrix(rep('-', 100), nrow = 10, ncol = 10)
x <- matrix(rep('-', 100), nrow = 10, ncol = 10)
x %*% t(x)
x <- matrix(rep('0', 100), nrow = 10, ncol = 10)
x %*% t(x)
x <- matrix(rep(0, 100), nrow = 10, ncol = 10)
x %*% t(x)
test <- expand.grid(1:10,1:10)
get.adjacency(graph.edgelist(as.matrix(test), directed=FALSE))
test_create <- function(nrow,ncol,n_walls) {
game_grid <- matrix(rep('-', nrow*ncol), nrow = nrow, ncol = ncol)
#2 define target coordinates
obj_x <- sample(1:nrow, 1)
obj_y <- sample(1:ncol, 1)
target_coord <- c(obj_x, obj_y)
#3define start coordinates
get_start_coord <- function() {
start_x <- sample(1:nrow, 1)
start_y <- sample(1:ncol, 1)
start_coord <- c(start_x, start_y)
#check if start coordinates are not target coordinates
if (target_coord[1] == start_coord[1] & target_coord[2] == start_coord[2]) {
get_start_coord()
}
return(start_coord)
}
start_coord <- get_start_coord()
#Create walls
create_walls <- function() {
#define walls
#create a grid of all coordinates
all_coords <- expand.grid(1:nrow, 1:ncol)
walls <- do.call(`rbind`, sample(asplit(all_coords, 1), n_walls))
walls_coords <- split(walls, seq(nrow(walls)))
return(walls_coords)
}
walls_coords <- create_walls()
#Check if start or target coords are not on a wall
while((list(target_coord) %in% walls_coords) | (list(start_coord) %in% walls_coords)) {
walls_coords <- create_walls()
}
#mark starting position on the grid
game_grid[start_coord[1], start_coord[2]] <- 'X'
#mark target position on the grid if debug
if(debug == TRUE) {
game_grid[target_coord[1], target_coord[2]] <- 'T'
}
for(i in walls_coords) {
game_grid[i[1],i[2]] <- '#'
}
}
test_create <- function(nrow,ncol,n_walls) {
game_grid <- matrix(rep('-', nrow*ncol), nrow = nrow, ncol = ncol)
#2 define target coordinates
obj_x <- sample(1:nrow, 1)
obj_y <- sample(1:ncol, 1)
target_coord <- c(obj_x, obj_y)
#3define start coordinates
get_start_coord <- function() {
start_x <- sample(1:nrow, 1)
start_y <- sample(1:ncol, 1)
start_coord <- c(start_x, start_y)
#check if start coordinates are not target coordinates
if (target_coord[1] == start_coord[1] & target_coord[2] == start_coord[2]) {
get_start_coord()
}
return(start_coord)
}
start_coord <- get_start_coord()
#Create walls
create_walls <- function() {
#define walls
#create a grid of all coordinates
all_coords <- expand.grid(1:nrow, 1:ncol)
walls <- do.call(`rbind`, sample(asplit(all_coords, 1), n_walls))
walls_coords <- split(walls, seq(nrow(walls)))
return(walls_coords)
}
walls_coords <- create_walls()
#Check if start or target coords are not on a wall
while((list(target_coord) %in% walls_coords) | (list(start_coord) %in% walls_coords)) {
walls_coords <- create_walls()
}
#mark starting position on the grid
game_grid[start_coord[1], start_coord[2]] <- 'X'
#mark target position on the grid if debug
if(debug == TRUE) {
game_grid[target_coord[1], target_coord[2]] <- 'T'
}
for(i in walls_coords) {
game_grid[i[1],i[2]] <- '#'
}
return(game_grid)
}
test <- test_create(10,10,20)
test_create <- function(nrow,ncol,n_walls) {
game_grid <- matrix(rep('-', nrow*ncol), nrow = nrow, ncol = ncol)
#2 define target coordinates
obj_x <- sample(1:nrow, 1)
obj_y <- sample(1:ncol, 1)
target_coord <- c(obj_x, obj_y)
#3define start coordinates
get_start_coord <- function() {
start_x <- sample(1:nrow, 1)
start_y <- sample(1:ncol, 1)
start_coord <- c(start_x, start_y)
#check if start coordinates are not target coordinates
if (target_coord[1] == start_coord[1] & target_coord[2] == start_coord[2]) {
get_start_coord()
}
return(start_coord)
}
start_coord <- get_start_coord()
#Create walls
create_walls <- function() {
#define walls
#create a grid of all coordinates
all_coords <- expand.grid(1:nrow, 1:ncol)
walls <- do.call(`rbind`, sample(asplit(all_coords, 1), n_walls))
walls_coords <- split(walls, seq(nrow(walls)))
return(walls_coords)
}
walls_coords <- create_walls()
#Check if start or target coords are not on a wall
while((list(target_coord) %in% walls_coords) | (list(start_coord) %in% walls_coords)) {
walls_coords <- create_walls()
}
#mark starting position on the grid
game_grid[start_coord[1], start_coord[2]] <- 'X'
#mark target position on the grid if debug
game_grid[target_coord[1], target_coord[2]] <- 'T'
for(i in walls_coords) {
game_grid[i[1],i[2]] <- '#'
}
return(game_grid)
}
test <- test_create(10,10,20)
test
test2 <- ifelse(test == '-',1,0)
test2 %*% t(test2)
test <- test_create(3,3,0)
test <- test_create(3,3,1)
test
expand.grid(1:3,1:3)
x <- expand.grid(1:3,1:3)
get.adjacency(graph.edgelist(as.matrix(x), directed=FALSE))
get.adjacency(graph.edgelist(as.matrix(x), directed=FALSE)) - 1
(get.adjacency(graph.edgelist(as.matrix(x), directed=FALSE)) - 1) |> graph_from_adjacency_matrix()
adj_mat <- get.adjacency(graph.edgelist(as.matrix(x), directed=FALSE)) - 1
graph_from_adjacency_matrix(adj_mat)
x <- expand.grid(1:5,1:5)
adj_mat <- get.adjacency(graph.edgelist(as.matrix(x), directed=FALSE)) - 1
graph_from_adjacency_matrix(adj_mat)
adj_mat
test_mat <- mattrix(rep(0, 81), nrow=9,ncol=9)
test_mat <- matrix(rep(0, 81), nrow=9,ncol=9)
names <-c('A','B','C','D','E','F','G','H','I')
colnames(test_mat) <- names
rownames(test_mat) <- names
View(test_mat)
library(shiny)
# Define UI for application that draws a histogram
ui <- fluidPage(
# Application title
titlePanel("Old Faithful Geyser Data"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
sliderInput("nrow",
"Number of rows:",
min = 3,
max = 20,
value = 10),
sliderInput("ncol",
"Number of columns:",
min = 3,
max = 20,
value = 10),
sliderInput("walls",
"Number of walls:",
min = 0,
max = 50,
value = 30),
),
# Show a plot of the generated distribution
mainPanel(
plotOutput("distPlot")
)
)
)
a
a
?includeCSS
current_coord <- c(1,4)
target_coord <- c(1,1)
sqrt((target_coord[1] - current_coord[1])**2 + (target_coord[2] - current_coord[2])**2)
target_coord <- c(3,1)
sqrt((target_coord[1] - current_coord[1])**2 + (target_coord[2] - current_coord[2])**2)
