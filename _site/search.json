[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "A few remarks on percentile scales\n\n\n\n\n\n\nstatistics\n\n\nsimulation\n\n\n\n\n\n\n\n\n\nMichał Wypych\n\n\n\n\n\n\n\n\n\n\n\n\nMake a game in R - shiny [part 2]\n\n\n\n\n\n\napps\n\n\ngames\n\n\n\n\n\n\n\n\n\nAug 18, 2023\n\n\nMichał Wypych\n\n\n\n\n\n\n\n\n\n\n\n\nMake a game in R\n\n\n\n\n\n\napps\n\n\ngames\n\n\n\n\n\n\n\n\n\nAug 10, 2023\n\n\nMichał Wypych\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Michał Wypych",
    "section": "",
    "text": "I’m Michał. I’m a social psychologist especially interested in emotions and language.\nI’m also passionate about R, data vizualisation and analysis. I teach an introduction to R course at Faculty of Psychology at University of Warsaw."
  },
  {
    "objectID": "portfolio/tidytuesday/index.html",
    "href": "portfolio/tidytuesday/index.html",
    "title": "#Tidytuesday",
    "section": "",
    "text": "Some of my tidytuesday contributions:"
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "Portfolio",
    "section": "",
    "text": "Applications\n\n\n\n\n\n\nMichał Wypych\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNational Parks in the USA\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTidytuesday\n\n\n\n\n\n\nMichał Wypych\n\n\nFeb 18, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/first-game/index.html",
    "href": "posts/first-game/index.html",
    "title": "Make a game in R",
    "section": "",
    "text": "The first idea for making this game came to me when I was thinking of exercises for students to practice loops. I feel that building simple games makes it easier for them to grasp the idea behind iteration and while loops than abstract operations on numbers and vectors.\nAnyway, I made a simple hot-and-cold game. If you haven’t heard about it (idk, maybe it’s just a polish/Easter European thing?) there rules are simple: you have to find a treasure that is hidden somewhere and others keep telling you if you are getting closer (‘hot’!) or further away (‘cold’!) from the object. That’s it, there’s nothing more to it.\nThe idea is to play on a rectangular grid, you can move up, down, left or right. After each move the game tells you if you are getting closer or further away from the treasure. You win when you reach the hidden treasure. Also, the fewer moves you need to get there, the better. Sounds simple enough, right? Once we have that we can move on to adding more complex things like obstacles on the grid or messing with the ui.\nBefore we get to actual coding it’s nice to lay out some plan of what we’ll need:\nOk, so lets do it (please note that I keep most of the code folded because it’s pretty long when taken together!)."
  },
  {
    "objectID": "posts/first-game/index.html#initial-conditions",
    "href": "posts/first-game/index.html#initial-conditions",
    "title": "Make a game in R",
    "section": "Initial conditions",
    "text": "Initial conditions\nWe know that we’ll need a few thing to even start the game: grid on which we will play, position of player and the treasure (that will be random) and the initial distance. We’ll use simple manhattan distance here (sum of distance in rows and columns). Lets create the scaffolding first:\n\nhot_and_cold &lt;- function(nrow, ncol, debug = FALSE) {\n  \n  # INITIALIZE THE GAME\n  \n  \n  #MOVEMENTS AND UPDATES\n  \n}\n\nWe’ll make a debug argument for now to make it easier to see what is exactly going on in the game (we’ll use it to toggle displaying the treasure). It’s something we’ll probably delete from the final game but it might be useful for debugging. The two other arguments: nrow and ncol will control the size of the grid we want to play on. Now lets fill the function with initial conditions for the game. We start with 2 checks - nrow and ncol need to be numbers. Next we create the game grid as a nrow by ncol matrix of - and define random target coordinates. Then we get starting coordinates. To do it we define a function that automatically checks if starting and target coordinates are the same. If they are the same the function starts from the beginning. If they are not it returns starting coordinates. The rest is pretty straightforward. If we are in debug mode we mark the target coordinates on the grid, we define current coordinates for future use in movements, calculate initial distance, start movement counter and display welcome message and the game grid.\n\n\nInitial conditions\nhot_and_cold &lt;- function(nrow, ncol, debug = FALSE) {\n  #checks: both arguments need to be numbers\n  stopifnot('You did not provide numbers' = is.numeric(nrow))\n  stopifnot('You did not provide numbers' = is.numeric(ncol))\n  # INITIALIZE THE GAME\n  #1 Define grid for the game\n  game_grid &lt;- matrix(rep('-', nrow*ncol), nrow = nrow, ncol = ncol)\n  \n  #2 define target coordinates\n  obj_x &lt;- sample(1:nrow, 1)\n  obj_y &lt;- sample(1:ncol, 1)\n  target_coord &lt;- c(obj_x, obj_y)\n  \n  \n  #3define start coordinates\n  get_start_coord &lt;- function() {\n    start_x &lt;- sample(1:nrow, 1)\n    start_y &lt;- sample(1:ncol, 1)\n    start_coord &lt;- c(start_x, start_y)\n    \n    #check if start coordinates are not target coordinates\n    if (setequal(start_coord, target_coord)) {\n      get_start_coord()\n    }\n    return(start_coord)\n  }\n  \n  start_coord &lt;- get_start_coord()\n  \n  #mark starting position on the grid\n  game_grid[start_coord[1], start_coord[2]] &lt;- 'X'\n  \n  #mark target position on the grid if debug\n  if(debug == TRUE) {\n    game_grid[target_coord[1], target_coord[2]] &lt;- 'T'\n  }\n  \n\n  #set current coordinates\n  current_coord &lt;- start_coord\n  \n  #calculate distance as Manhattan\n  \n  old_distance &lt;- sum(abs(target_coord[1] - current_coord[1]),abs(target_coord[2] - current_coord[2]))\n  \n  #initiate move counter\n  \n  n_moves &lt;- 1\n  \n  #display the first grid and instructions\n  print('You have to find the treasure. You can move by typing')\n  print('up, down, left or right. X shows your current position')\n  print('You cant walk over walls which are shown with #')\n  print('after each move the game will tell you if you are getting')\n  print('closer (Hot) or further (cold)')\n  print(game_grid)\n  \n  \n  #MOVEMENTS AND UPDATES\n  \n}\n\n\nNow if we run the function it should display the grid and initial position\n\nhot_and_cold(10,10)\n\n[1] \"You have to find the treasure. You can move by typing\"\n[1] \"up, down, left or right. X shows your current position\"\n[1] \"You cant walk over walls which are shown with #\"\n[1] \"after each move the game will tell you if you are getting\"\n[1] \"closer (Hot) or further (cold)\"\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,] \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \n [2,] \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"X\"  \n [3,] \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \n [4,] \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \n [5,] \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \n [6,] \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \n [7,] \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \n [8,] \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \n [9,] \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \n[10,] \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\"  \"-\""
  },
  {
    "objectID": "posts/first-game/index.html#movements-and-updating",
    "href": "posts/first-game/index.html#movements-and-updating",
    "title": "Make a game in R",
    "section": "Movements and updating",
    "text": "Movements and updating\nOk, we have the grid set up! Now, on to movements. There are 4 ways to move on the grid: up, down, left or right. What we’ll need is to make the function listen to the user and depending on which movement they specify make the necessary checks (we don’t want to fall off the grid!) and change the current position and distance. All of this will have to keep going for as long as current coordinates and target coordinates don’t overlap - a while loop will be perfect for this. As long as current coordinates and target coordinates don’t overlap we listen to user movement (readline function) and if the move is “up” we first check if this move will take us out of the grid (if it does we display a message and skip to the next iteration of the loop). If the move is valid we update current coordinates, recalculate distance and display appropriate message. We will need something like this:\n\n\nfirst move\nwhile(!setequal(current_coord, target_coord)) {\n  movement &lt;- readline('Where do you move: ')\n  if (movement == 'up') {\n      #check if you get ouside of the grid\n      if (current_coord[1] - 1 &lt; 1) {\n        print('You cant move there!')\n        next # this will force R to move to the next iteration of the loop\n      } \n      #update grid and coords\n      game_grid[current_coord[1], current_coord[2]] &lt;- '-'\n      current_coord[1] = current_coord[1] - 1\n      game_grid[current_coord[1], current_coord[2]] &lt;- 'X'\n      \n      #update distance and number of moves\n      new_distance &lt;- sum(abs(target_coord[1] - current_coord[1]),abs(target_coord[2] - current_coord[2]))\n      n_moves &lt;- n_moves + 1\n      \n      #display message\n      if(new_distance &lt; old_distance) {\n        print('Hotter!')\n      } else if (new_distance &gt; old_distance) {\n        print('Colder!')\n      }\n      #update distance\n      old_distance &lt;- new_distance\n      #print grid and make next move\n      print(game_grid)\n  }\n}\n\n\nNow, we’ll need four of these: one for each type of movement. This might be tedious to do by hand and might be error-prone. so it should be easier to manage if we put this in a function! The function should take 2 arguments: are we moving on horizontal or vertical axis and whether we should add or subtract.\n\n\nmovememnt function\nmake_move &lt;- function(h = 1, add = 1) {\n    \n    if (h == 1 & add == 1) {\n      if (current_coord[h] + add &gt; nrow) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n    } else if (h == 1 & add==-1) {\n      if (current_coord[h] + add &lt; 1) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n    } else if (h == 2 & add==1) {\n      if (current_coord[h] + add &gt; ncol) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n    } else if (h == 2 & add==-1) {\n      if (current_coord[h] + add &lt; 1) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n    }\n    \n    \n    #update grid and coords\n    game_grid[current_coord[1], current_coord[2]] &lt;&lt;- '-'\n    current_coord[h] &lt;&lt;- current_coord[h] + add\n    game_grid[current_coord[1], current_coord[2]] &lt;&lt;- 'X'\n    \n    #update distance and number of moves\n    new_distance &lt;&lt;- sum(abs(target_coord[1] - current_coord[1]),abs(target_coord[2] - current_coord[2]))\n    n_moves &lt;&lt;- n_moves + 1\n    \n    #display message\n    if(new_distance &lt; old_distance) {\n      print('Hotter!')\n    } else if (new_distance &gt; old_distance) {\n      print('Colder!')\n    }\n    #update distance\n    old_distance &lt;&lt;- new_distance\n    #print grid and make next move\n    print(game_grid)\n  }\n\n\nNow we can put the function into the game:\n\n\ngame with moves\nhot_and_cold &lt;- function(nrow, ncol, debug = FALSE) {\n  #checks: both arguments need to be numbers\n  stopifnot('You did not provide numbers' = is.numeric(nrow))\n  stopifnot('You did not provide numbers' = is.numeric(ncol))\n  # INITIALIZE THE GAME\n  #1 Define grid for the game\n  game_grid &lt;- matrix(rep('-', nrow*ncol), nrow = nrow, ncol = ncol)\n  \n  #2 define target coordinates\n  obj_x &lt;- sample(1:nrow, 1)\n  obj_y &lt;- sample(1:ncol, 1)\n  target_coord &lt;- c(obj_x, obj_y)\n  \n  \n  #3define start coordinates\n  get_start_coord &lt;- function() {\n    start_x &lt;- sample(1:nrow, 1)\n    start_y &lt;- sample(1:ncol, 1)\n    start_coord &lt;- c(start_x, start_y)\n    \n    #check if start coordinates are not target coordinates\n    if (identical(start_coord, target_coord)) {\n      get_start_coord()\n    }\n    return(start_coord)\n  }\n  \n  start_coord &lt;- get_start_coord()\n  \n  #mark starting position on the grid\n  game_grid[start_coord[1], start_coord[2]] &lt;- 'X'\n  \n  #mark target position on the grid if debug\n  if(debug == TRUE) {\n    game_grid[target_coord[1], target_coord[2]] &lt;- 'T'\n  }\n  \n\n  #set current coordinates\n  current_coord &lt;- start_coord\n  \n  #calculate distance as Manhattan\n  \n  old_distance &lt;- sum(abs(target_coord[1] - current_coord[1]),abs(target_coord[2] - current_coord[2]))\n  \n  #initiate move counter\n  \n  n_moves &lt;- 1\n  \n  #display the first grid and instructions\n  print('You have to find the treasure. You can move by typing')\n  print('up, down, left or right. X shows your current position')\n  print('You cant walk over walls which are shown with #')\n  print('after each move the game will tell you if you are getting')\n  print('closer (Hot) or further (cold)')\n  print(game_grid)\n  \n  \n  #MOVEMENTS AND UPDATES\n  # define function for making a move:\n  make_move &lt;- function(h = 1, add = 1) {\n    \n    if (h == 1 & add == 1) {\n      if (current_coord[h] + add &gt; nrow) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n    } else if (h == 1 & add==-1) {\n      if (current_coord[h] + add &lt; 1) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n    } else if (h == 2 & add==1) {\n      if (current_coord[h] + add &gt; ncol) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n    } else if (h == 2 & add==-1) {\n      if (current_coord[h] + add &lt; 1) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n    }\n    \n    \n    #update grid and coords\n    game_grid[current_coord[1], current_coord[2]] &lt;&lt;- '-'\n    current_coord[h] &lt;&lt;- current_coord[h] + add\n    game_grid[current_coord[1], current_coord[2]] &lt;&lt;- 'X'\n    \n    #update distance and number of moves\n    new_distance &lt;&lt;- sum(abs(target_coord[1] - current_coord[1]),abs(target_coord[2] - current_coord[2]))\n    n_moves &lt;&lt;- n_moves + 1\n    \n    #display message\n    if(new_distance &lt; old_distance) {\n      print('Hotter!')\n    } else if (new_distance &gt; old_distance) {\n      print('Colder!')\n    }\n    #update distance\n    old_distance &lt;&lt;- new_distance\n    #print grid and make next move\n    print(game_grid)\n  }\n  \n  \n  #start the while loop\n  while(!identical(current_coord, target_coord)) {\n    movement &lt;- readline('Where do you move: ')\n    #if movement up\n    if (movement == 'up') {\n      make_move(1, -1)\n    } else if (movement == 'down') {\n      make_move(1,1)\n    } else if (movement == 'left') {\n      make_move(2,-1)\n    } else if (movement == 'right') {\n      make_move(2,1)\n    } else {\n      print('this is not a move!') # if the input does not match the possible moves\n      \n    }\n  } # when the coordinates match while loop ends: we won!\n  print('Congratulations! You found the treasure')\n  print(paste('it took you', n_moves,'moves'))\n}\n\n\nNow you should have a working version of the game! You created the initial conditions to start the game, defined the rules of the game and how it should update according to the moves as well as winning conditions that end the game!"
  },
  {
    "objectID": "posts/first-game/index.html#adding-stuff---obstacles",
    "href": "posts/first-game/index.html#adding-stuff---obstacles",
    "title": "Make a game in R",
    "section": "Adding stuff - obstacles",
    "text": "Adding stuff - obstacles\nOk, we have a working version of the game but it’s still pretty boring: all you need to do is find the proper row and then proper column to get to the treasure. Not much to it. So how about we make it a bit more interesting and introduce obstacles on the grid: walls that you can’t walk on. Again, lets start with what we’ll need to do:\n\nCreate a set of coordinates for the walls\nMake sure that these do not overlap with the starting or target coordinates\nMake sure that there is a way from starting position to treasure\nDefine rules that forbid walking on walls\n\nThe first two and number 4 are actually pretty easy as they will be very similar to what we have already done. Number 3 is much more tricky as it requires a different distance algorithm but we’ll get to that later (although number 4 proved for some weird reason pretty challenging as well).\nIn order to create coordinates for walls we want to get a set of pairs of numbers that will indicate the coordinates and then store them (e.g. as a list of vectors). We want to let the user define how many walls they want on the board. We do it by defining all possible coordinates, sampling from them and then performing a check for overlap with starting and target position. The check basically tells R that as long as target or starting coordinates are within the list of wall coordinates, keep regenerating the walls.\n\n#Create walls\n  create_walls &lt;- function() {\n    #define walls\n    \n    #create a grid of all coordinates\n    all_coords &lt;- expand.grid(1:nrow, 1:ncol)\n    \n    #sample n_walls coordinates\n    walls &lt;- do.call(`rbind`, sample(asplit(all_coords, 1), n_walls))\n    \n    #save them as a list (makes for  easier checks later)\n    walls_coords &lt;- split(walls, seq(nrow(walls)))\n    \n    return(walls_coords)\n  }\n  \n  walls_coords &lt;- create_walls()\n  \n  #Check if start or target coords are not on a wall\n  while((list(target_coord) %in% walls_coords) | (list(start_coord) %in% walls_coords)) {\n    walls_coords &lt;- create_walls()\n  }\n\nNext we’ll need to add checks to our make_move() function to include checks if we are stepping on a wall. Essentially they are almost the same as checks for walking outside of the board, we just need to check against all the wall coordinates. The check looks something like this:\n\nif (list(as.integer(c(current_coord[1] -1,current_coord[2]))) %in% walls_coords) {\n      #check if you walk on a wall\n        print('You cant move there!')\n        next\n      }\n\nThe weird thing is that I needed to add as.integer(). This cost me quite a bit of time actually. Without it the game would not let you walk on some walls but would be totally fine with walking over some other walls. The reason for this is that %in% uses match() which converts to character. And adjacent values (like c(1,2)) become 1:2 which is not the same as c(1,2) when converted to text ( I didn’t come up with this, I asked a question and got an answer here). Anyway, we just need to put that code into our make_move() function and adjust accordingly to the type of move we make. Our updated function will look like this\n\n\nmovement function with walls\nmake_move &lt;- function(h = 1, add = 1) {\n    \n    #if h == 1: check walls, if add = 1 - check outside bounds else check other bounds\n    # same for h == 2\n    \n    if (h == 1 & add == 1) {\n      if (current_coord[h] + add &gt; nrow) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n      if (list(as.integer(c(current_coord[1]+ add,current_coord[2] ))) %in% walls_coords) {\n        #check if you walk on a wall\n        print('You cant move there!')\n        return()\n      }\n    } else if (h == 1 & add==-1) {\n      if (current_coord[h] + add &lt; 1) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n      if (list(as.integer(c(current_coord[1] + add,current_coord[2]))) %in% walls_coords) {\n        #check if you walk on a wall\n        print('You cant move there!')\n        return()\n      }\n      \n    } else if (h == 2 & add==1) {\n      if (current_coord[h] + add &gt; ncol) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n      if (list(as.integer(c(current_coord[1],current_coord[2]+ add))) %in% walls_coords) {\n        #check if you walk on a wall\n        print('You cant move there!')\n        return()\n      }\n      \n    } else if (h == 2 & add==-1) {\n      if (current_coord[h] + add &lt; 1) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n      if (list(as.integer(c(current_coord[1] ,current_coord[2]+ add))) %in% walls_coords) {\n        #check if you walk on a wall\n        print('You cant move there!')\n        return()\n      }\n    }\n    \n    \n    #update grid and coords\n    game_grid[current_coord[1], current_coord[2]] &lt;&lt;- '-'\n    current_coord[h] &lt;&lt;- current_coord[h] + add\n    game_grid[current_coord[1], current_coord[2]] &lt;&lt;- 'X'\n    \n    #update distance and number of moves\n    new_distance &lt;&lt;- sum(abs(target_coord[1] - current_coord[1]),abs(target_coord[2] - current_coord[2]))\n    n_moves &lt;&lt;- n_moves + 1\n    \n    #display message\n    if(new_distance &lt; old_distance) {\n      print('Hotter!')\n    } else if (new_distance &gt; old_distance) {\n      print('Colder!')\n    }\n    #update distance\n    old_distance &lt;&lt;- new_distance\n    #print grid and make next move\n    print(game_grid)\n  }\n\n\nNow if we change the make_move() function in our game, we’ll get a game with a random set of walls! There is one last check to make: make sure that the game is winnable - there needs to be a path from starting position to treasure position. If the path is blocked by walls then there is no way to win the game. This one is actually a bit more complicated because we need some kind of algorithm that checks if such a path exists. A way to do it is to calculate the shortest path from start to target position while taking into account the walls. If such path exists - the game is winnable. We can use what is called breadth first search to do this.\n\nBreadth first search\nBasically what the algorithm does is it starts from a certain node in a graph (our starting position) and visits all neighbour nodes connected to the initial node, then it moves to all neighbours of the neighbours and so on until all possible routes from the initial node have been explored. In our game only the cells that are adjacent and are not walls are connected. If the position of the treasure shows up in the BFS then the game is winnable! There’s plenty of resources on this algorithm online if you want to learn more about it (just some example here).\nThe implementation of BFS in R is not straightforward. First of all we are not working with a nice graph structure (I wanted to keep this game without using any additional packages like igraph) but with a matrix. This means we don’t have anything like adjacency matrix to work with (that’s a matrix that would give us information about which cells are connected to each other). The solution below is probably not the nicest one but it works so it’ll have to suffice. You can see the entire function (actually 2) here:\n\n\nBreadth first search\n#First we need to define valid moves in the grid for the algorithm\nis_valid_move &lt;- function(row, col, n, p, visited) {\n      # Check if the cell is within the bounds of the matrix\n      if (row &lt; 1 || row &gt; n || col &lt; 1 || col &gt; p) {\n        return(FALSE)\n      }\n      \n      # Check if the cell has already been visited\n      if (visited[row, col]) {\n        return(FALSE)\n      }\n      \n      # Check if the cell is valid (i.e., contains \"-\", \"X\", or \"T\")\n      if (!(game_grid[row, col] %in% c(\"-\", \"X\", \"T\"))) {\n        return(FALSE)\n      }\n      \n      # If all conditions are satisfied, the move is valid\n      return(TRUE)\n    }\n    \n    # Define the function to find a path between \"X\" and \"T\"\n    find_path &lt;- function(game_grid) {\n      # Define the start and end cells\n      start_row &lt;- which(game_grid == \"X\", arr.ind = TRUE)[1]\n      start_col &lt;- which(game_grid == \"X\", arr.ind = TRUE)[2]\n      end_row &lt;- which(game_grid == \"T\", arr.ind = TRUE)[1]\n      end_col &lt;- which(game_grid == \"T\", arr.ind = TRUE)[2]\n      \n      # Define the queue and visited matrix\n      queue &lt;- list()\n      visited &lt;- matrix(FALSE, nrow = nrow(game_grid), ncol = ncol(game_grid))\n      \n      # Add the start cell to the queue\n      queue[[1]] &lt;- c(start_row, start_col, 0)\n      \n      # Loop until the queue is empty\n      while (length(queue) &gt; 0) {\n        # Get the first cell in the queue\n        curr_cell &lt;- unlist(queue[[1]])\n        curr_row &lt;- curr_cell[1]\n        curr_col &lt;- curr_cell[2]\n        curr_dist &lt;- curr_cell[3]\n        \n        # Remove the first cell from the queue\n        queue &lt;- queue[-1]\n        \n        # Mark the cell as visited\n        visited[curr_row, curr_col] &lt;- TRUE\n        \n        # Check if the current cell is the end cell\n        if (curr_row == end_row && curr_col == end_col) {\n          # Return the distance from the start cell to the end cell\n          return(curr_dist)\n        }\n        \n        # Check the neighboring cells\n        neighbor_cells &lt;- list(c(curr_row - 1, curr_col), c(curr_row + 1, curr_col), \n                               c(curr_row, curr_col - 1), c(curr_row, curr_col + 1))\n        for (neighbor_cell in neighbor_cells) {\n          neighbor_row &lt;- neighbor_cell[1]\n          neighbor_col &lt;- neighbor_cell[2]\n          \n          if (is_valid_move(neighbor_row, neighbor_col, nrow(game_grid), ncol(game_grid), visited)) {\n            # Add the neighboring cell to the queue\n            queue[[length(queue) + 1]] &lt;- c(neighbor_row, neighbor_col, curr_dist + 1)\n          }\n        }\n      }\n      \n      # If no path is found, return FALSE\n      return(FALSE)\n    }\n\n\nWhat this solution gives us is:\n\nGive rules to define connections between cells in a matrix (so how to “turn” the matrix into a graph). This is done with the is_valid_move() function. It allows us to check if it is possible to make a given move and if a given cell that we want to move to has already been visited.\nImplement BFS. This is what the find_path() function does. It gets the starting and target coordinates, queue of cells to visit and matrix of visited cells and then starts moving through the grid. If it gets to target coordinates it returns current distance, if it doesn’t (after visiting all possible cells) it returns false.\nThanks to this we can make sure that the game can be won (and regenerate walls if it is not). The last thing we need to do is put the BFS to good use inside our hot_and_cold() function. We just need to modify the code that sets the initial conditions before the game begins:\n\n\n\nPutting BFS to use\n for(i in walls_coords) {\n    game_grid[i[1],i[2]] &lt;- '#'\n  }\n  \n  game_grid[start_coord[1], start_coord[2]] &lt;- 'X'\n  game_grid[target_coord[1], target_coord[2]] &lt;- 'T'\n  \n  bfs_result &lt;- find_path(game_grid)\n  \n  while(!bfs_result) {\n    #regenerate walls\n    walls_coords &lt;- create_walls()\n    game_grid &lt;- matrix(rep('-', nrow*ncol), nrow = nrow, ncol = ncol)\n    for(i in walls_coords) {\n      game_grid[i[1],i[2]] &lt;- '#'\n    }\n    \n    game_grid[start_coord[1], start_coord[2]] &lt;- 'X'\n    game_grid[target_coord[1], target_coord[2]] &lt;- 'T'\n    bfs_result &lt;- find_path(game_grid)\n    \n  }\n  \n  \n  if(debug == FALSE) {\n    game_grid[target_coord[1], target_coord[2]] &lt;- '-'\n  }\n\n\nThe entire game now looks like this (that’s quite a few lines of code):\n\n\nThe full game\nhot_and_cold &lt;- function(nrow, ncol, n_walls, debug = FALSE) {\n  #checks: both arguments need to be numbers\n  stopifnot('You did not provide numbers' = is.numeric(nrow))\n  stopifnot('You did not provide numbers' = is.numeric(ncol))\n  # INITIALIZE THE GAME\n  #1 Define grid for the game\n  game_grid &lt;- matrix(rep('-', nrow*ncol), nrow = nrow, ncol = ncol)\n  \n  #2 define target coordinates\n  obj_x &lt;- sample(1:nrow, 1)\n  obj_y &lt;- sample(1:ncol, 1)\n  target_coord &lt;- c(obj_x, obj_y)\n  \n  \n  #3define start coordinates\n  get_start_coord &lt;- function() {\n    start_x &lt;- sample(1:nrow, 1)\n    start_y &lt;- sample(1:ncol, 1)\n    start_coord &lt;- c(start_x, start_y)\n    \n    #check if start coordinates are not target coordinates\n    if (target_coord[1] == start_coord[1] & target_coord[2] == start_coord[2]) {\n      get_start_coord()\n    }\n    return(start_coord)\n  }\n  \n  start_coord &lt;- get_start_coord()\n  \n  #Create walls\n  create_walls &lt;- function() {\n    #define walls\n    \n    #create a grid of all coordinates\n    all_coords &lt;- expand.grid(1:nrow, 1:ncol)\n    \n    walls &lt;- do.call(`rbind`, sample(asplit(all_coords, 1), n_walls))\n    \n    walls_coords &lt;- split(walls, seq(nrow(walls)))\n    \n    return(walls_coords)\n  }\n  \n  walls_coords &lt;- create_walls()\n  \n  #Check if start or target coords are not on a wall\n  while((list(target_coord) %in% walls_coords) | (list(start_coord) %in% walls_coords)) {\n    walls_coords &lt;- create_walls()\n  }\n  \n  #BFS ALGORITHM TO CHECK IF GAME IS WINNABLE\n  is_valid_move &lt;- function(row, col, n, p, visited) {\n    # Check if the cell is within the bounds of the matrix\n    if (row &lt; 1 || row &gt; n || col &lt; 1 || col &gt; p) {\n      return(FALSE)\n    }\n    \n    # Check if the cell has already been visited\n    if (visited[row, col]) {\n      return(FALSE)\n    }\n    \n    # Check if the cell is valid (i.e., contains \"-\", \"X\", or \"T\")\n    if (!(game_grid[row, col] %in% c(\"-\", \"X\", \"T\"))) {\n      return(FALSE)\n    }\n    \n    # If all conditions are satisfied, the move is valid\n    return(TRUE)\n  }\n  \n  # Define the function to find a path between \"X\" and \"T\"\n  find_path &lt;- function(game_grid) {\n    # Define the start and end cells\n    start_row &lt;- which(game_grid == \"X\", arr.ind = TRUE)[1]\n    start_col &lt;- which(game_grid == \"X\", arr.ind = TRUE)[2]\n    end_row &lt;- which(game_grid == \"T\", arr.ind = TRUE)[1]\n    end_col &lt;- which(game_grid == \"T\", arr.ind = TRUE)[2]\n    \n    # Define the queue and visited matrix\n    queue &lt;- list()\n    visited &lt;- matrix(FALSE, nrow = nrow(game_grid), ncol = ncol(game_grid))\n    \n    # Add the start cell to the queue\n    queue[[1]] &lt;- c(start_row, start_col, 0)\n    \n    # Loop until the queue is empty\n    while (length(queue) &gt; 0) {\n      # Get the first cell in the queue\n      curr_cell &lt;- unlist(queue[[1]])\n      curr_row &lt;- curr_cell[1]\n      curr_col &lt;- curr_cell[2]\n      curr_dist &lt;- curr_cell[3]\n      \n      # Remove the first cell from the queue\n      queue &lt;- queue[-1]\n      \n      # Mark the cell as visited\n      visited[curr_row, curr_col] &lt;- TRUE\n      \n      # Check if the current cell is the end cell\n      if (curr_row == end_row && curr_col == end_col) {\n        # Return the distance from the start cell to the end cell\n        return(curr_dist)\n      }\n      \n      # Check the neighboring cells\n      neighbor_cells &lt;- list(c(curr_row - 1, curr_col), c(curr_row + 1, curr_col), \n                             c(curr_row, curr_col - 1), c(curr_row, curr_col + 1))\n      for (neighbor_cell in neighbor_cells) {\n        neighbor_row &lt;- neighbor_cell[1]\n        neighbor_col &lt;- neighbor_cell[2]\n        \n        if (is_valid_move(neighbor_row, neighbor_col, nrow(game_grid), ncol(game_grid), visited)) {\n          # Add the neighboring cell to the queue\n          queue[[length(queue) + 1]] &lt;- c(neighbor_row, neighbor_col, curr_dist + 1)\n        }\n      }\n    }\n    \n    # If no path is found, return FALSE\n    return(FALSE)\n  }\n  #add a check that there exists a path! We'll need the BFS for this\n  \n  \n  #display the first grid and instructions\n  #change elements of grid to walls:\n  for(i in walls_coords) {\n    game_grid[i[1],i[2]] &lt;- '#'\n  }\n  \n  game_grid[start_coord[1], start_coord[2]] &lt;- 'X'\n  game_grid[target_coord[1], target_coord[2]] &lt;- 'T'\n  \n  bfs_result &lt;- find_path(game_grid)\n  \n  while(!bfs_result | (list(target_coord) %in% walls_coords) | (list(start_coord) %in% walls_coords)) {\n    #regenerate walls\n    walls_coords &lt;- create_walls()\n    game_grid &lt;- matrix(rep('-', nrow*ncol), nrow = nrow, ncol = ncol)\n    for(i in walls_coords) {\n      game_grid[i[1],i[2]] &lt;- '#'\n    }\n    \n    game_grid[start_coord[1], start_coord[2]] &lt;- 'X'\n    game_grid[target_coord[1], target_coord[2]] &lt;- 'T'\n    bfs_result &lt;- find_path(game_grid)\n    \n  }\n  \n  \n  \n  if(debug == FALSE) {\n    game_grid[target_coord[1], target_coord[2]] &lt;- '-'\n  }\n  \n  \n  #set current coordinates\n  current_coord &lt;- start_coord\n  \n  #calculate distance as Manhattan\n  \n  old_distance &lt;- sum(abs(target_coord[1] - current_coord[1]),abs(target_coord[2] - current_coord[2]))\n  \n  #initiate move counter\n  \n  n_moves &lt;- 1\n  \n  #display the first grid and instructions\n  print('You have to find the treasure. You can move by typing')\n  print('up, down, left or right. X shows your current position')\n  print('You cant walk over walls which are shown with #')\n  print('after each move the game will tell you if you are getting')\n  print('closer (Hot) or further (cold)')\n  print(game_grid)\n  \n  \n  #MOVEMENTS AND UPDATES\n  # define function for making a move:\n  make_move &lt;- function(h = 1, add = 1) {\n    \n    #if h == 1: check walls, if add = 1 - check outside bounds else check other bounds\n    # same for h == 2\n    \n    if (h == 1 & add == 1) {\n      if (current_coord[h] + add &gt; nrow) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n      if (list(as.integer(c(current_coord[1]+ add,current_coord[2] ))) %in% walls_coords) {\n        #check if you walk on a wall\n        print('You cant move there!')\n        return()\n      }\n    } else if (h == 1 & add==-1) {\n      if (current_coord[h] + add &lt; 1) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n      if (list(as.integer(c(current_coord[1] + add,current_coord[2]))) %in% walls_coords) {\n        #check if you walk on a wall\n        print('You cant move there!')\n        return()\n      }\n      \n    } else if (h == 2 & add==1) {\n      if (current_coord[h] + add &gt; ncol) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n      if (list(as.integer(c(current_coord[1],current_coord[2]+ add))) %in% walls_coords) {\n        #check if you walk on a wall\n        print('You cant move there!')\n        return()\n      }\n      \n    } else if (h == 2 & add==-1) {\n      if (current_coord[h] + add &lt; 1) {\n        print('You cant move there!')\n        print(game_grid)\n        return() # this will force R to move to the next iteration of the loop\n      } \n      if (list(as.integer(c(current_coord[1] ,current_coord[2]+ add))) %in% walls_coords) {\n        #check if you walk on a wall\n        print('You cant move there!')\n        return()\n      }\n    }\n    \n    \n    #update grid and coords\n    game_grid[current_coord[1], current_coord[2]] &lt;&lt;- '-'\n    current_coord[h] &lt;&lt;- current_coord[h] + add\n    game_grid[current_coord[1], current_coord[2]] &lt;&lt;- 'X'\n    \n    #update distance and number of moves\n    new_distance &lt;&lt;- sum(abs(target_coord[1] - current_coord[1]),abs(target_coord[2] - current_coord[2]))\n    n_moves &lt;&lt;- n_moves + 1\n    \n    #display message\n    if(new_distance &lt; old_distance) {\n      print('Hotter!')\n    } else if (new_distance &gt; old_distance) {\n      print('Colder!')\n    }\n    #update distance\n    old_distance &lt;&lt;- new_distance\n    #print grid and make next move\n    print(game_grid)\n  }\n  \n  \n  #start the while loop\n  while(!(target_coord[1] == current_coord[1] & target_coord[2] == current_coord[2])) {\n    movement &lt;- readline('Where do you move: ')\n    #if movement up\n    if (movement == 'up') {\n      make_move(1, -1)\n    } else if (movement == 'down') {\n      make_move(1,1)\n    } else if (movement == 'left') {\n      make_move(2,-1)\n    } else if (movement == 'right') {\n      make_move(2,1)\n    } else {\n      print('this is not a move!') # if the input does not match the possible moves\n      \n    }\n  } # when the coordinates match while loop ends: we won!\n  print('Congratulations! You found the treasure')\n  print(paste('it took you', n_moves,'moves'))\n}\n\n\nYay, we have a game! In the next installment we’ll try to work on the appearance of the game - now it’s just a R console game that shows a bunch of # and -. We’ll try to make it look better. Also please note that this is not really optimized code so for large grids and very high number of walls it may take a while for the game to generate the game grid. However, this post has already gotten really long and I won’t try to make the code faster for now.\nThe image used in the post thumbnail is taken from https://unsplash.com/photos/A_Z–0ey4HQ."
  },
  {
    "objectID": "posts/first-game-2/index.html",
    "href": "posts/first-game-2/index.html",
    "title": "Make a game in R - shiny [part 2]",
    "section": "",
    "text": "As you may recall in the previous post we’ve built a simple game in R that is about finding a treasure by following some clues. The game works fine in the R console but it does not look good. In this post I want to focus on messing with the ui - lets put the game into a shiny app!"
  },
  {
    "objectID": "posts/first-game-2/index.html#brief-overview-of-shiny",
    "href": "posts/first-game-2/index.html#brief-overview-of-shiny",
    "title": "Make a game in R - shiny [part 2]",
    "section": "Brief overview of shiny",
    "text": "Brief overview of shiny\nI won’t go into details about shiny in this post because it would take way too long (if you want to you can go here). The general idea behind making interactive web apps with shiny is to split them into 2 components: user interface (UI) and the server. UI is the part that controls how things are displayed. The server side is where all calculations happen. We will generally follow this logic with one exception: we’ll keep all the big and important functions for the game in a separate file so that the app file contains only the shiny stuff. we’ll also be using the shinyalert package for rendering messages. If you’re interested in making games in shiny there are some great materials by Jesse Mostipak and Barret Schloerke e.g. here."
  },
  {
    "objectID": "posts/first-game-2/index.html#roadmap",
    "href": "posts/first-game-2/index.html#roadmap",
    "title": "Make a game in R - shiny [part 2]",
    "section": "Roadmap",
    "text": "Roadmap\nIn order to transfer our game into a shiny app we’ll have to build 2 things: the interface of the app (ui) and the server side. In the ui we’ll need:\n\nsome inputs to define the game parameters (number of rows, columns and walls) and a button to launch the game\nbuttons to define movements\nsome decent-looking way to display the game grid.\nWe’ll also have to put the clues ( ‘hotter’, ‘colder’), a welcome and winning message.\n\nThe server side will need a few things as well. We’ll need to tinker with our game functions to make it launch with given parameters when the start button is pressed and then to listen to the user making each move and update the game grid accordingly. We’ll also need to generate clues so that they are displayed properly in the ui and some flashy way to end the game.\nOnce we have these things we should be able to launch and play the game!"
  },
  {
    "objectID": "posts/first-game-2/index.html#building-the-ui",
    "href": "posts/first-game-2/index.html#building-the-ui",
    "title": "Make a game in R - shiny [part 2]",
    "section": "Building the ui",
    "text": "Building the ui\nLets start with building the ui for our game. We’ll start by defining the title panel and the layout. We’ll use sidebar to manage the inputs and leave plenty of space for the game grid.\n\n\nUI structure\nlibrary(shiny)\nlibrary(shinyalert)\n\n# Define UI\nui &lt;- fluidPage(\n  \n    # Application title\n    titlePanel(\"Hot and cold\"),\n    #define sidebar layout\n    sidebarLayout(\n      #all our inputs and play button will go into the sidebarPanel\n      sidebarPanel(),\n      \n      #the game grid and movement buttons will be in the main panel\n      mainPanel()\n    )\n)    \n\n\nOk, we have the general layout, lets fill it with some inputs! We need 3 inputs: number of rows, columns and walls plus a button that will initialize the game. NumericInput() will definitely do the job and we don’t need anything more fancy here. Each numeric input needs an id that will later be referenced in the server side to retrieve its value, a label to display and a set of values: range + a default value to display. I’ve set the possible range for rows and columns from 2 to 20. More than 20 would probably make the game difficult to play on a computer screen because the cells would be really tiny. The limit for walls is from 1 to 100 (though you can set a different one). Buttons are created with actionButton() which also need an id and a label. I added an additional class which will make styling it easier.\n\n\nUI with inputs\nlibrary(shiny)\nlibrary(shinyalert)\n\nui &lt;- fluidPage(\n    # Application title\n    titlePanel(\"Hot and cold\"),\n    sidebarLayout(\n      sidebarPanel(\n        numericInput(\"nrow\", \"Number of rows\", value = 5, min = 2, max = 20),\n        numericInput(\"ncol\", \"Number of columns\", value = 5, min = 2, max = 20),\n        numericInput(\"walls\", \"Number of walls\", value = 1, min = 1, max = 100),\n        actionButton(\"play\", \"PLAY!\", class = \"btn-lg btn-success\")\n      ),\n      mainPanel()\n        \n    )    \n)\n\n\nNow, on to the main panel. We’ll need to put the game grid in it. We can render it as a table with tableOutput() (don’t worry it does not look great for now, we’ll make it prettier soon). We’ll also need to define buttons for moving in each directions. For each button we can use the same function as for the play button, just with different ids and labels. One additional thing to note is that we are using fluidRow() for the buttons. This way the buttons will be displayed below the table.\n\n\nUI with inputs and outputs\nlibrary(shiny)\nlibrary(shinyalert)\n\nui &lt;- fluidPage(\n    # Application title\n    titlePanel(\"Hot and cold\"),\n    sidebarLayout(\n      #trying to wrap in a div to set background color for sideb\n      \n      sidebarPanel(id=\"sidebar\",\n        numericInput(\"nrow\", \"Number of rows\", value = 5, min = 1, max = 20),\n        numericInput(\"ncol\", \"Number of columns\", value = 5, min = 1, max = 20),\n        numericInput(\"walls\", \"Number of walls\", value = 1, min = 1, max = 50),\n        actionButton(\"play\", \"PLAY!\", class = \"btn-lg btn-success\")\n      ),\n      mainPanel(\n          tableOutput(\"matrix\"),\n        fluidRow(\n          actionButton(\"left\", \"LEFT\", class = \"btn-lg btn-success\"),\n          actionButton(\"up\", \"UP\", class = \"btn-lg btn-success\"),\n          actionButton(\"down\", \"DOWN\", class = \"btn-lg btn-success\"),\n          actionButton(\"right\", \"RIGHT\", class = \"btn-lg btn-success\")\n        )\n      )\n    )    \n)\n\n\nNow we have the general ui for the game ready. We’ll add a few things later to make it look better but for now we can leave it as it is. We can move on to the server side."
  },
  {
    "objectID": "posts/first-game-2/index.html#building-the-server-side",
    "href": "posts/first-game-2/index.html#building-the-server-side",
    "title": "Make a game in R - shiny [part 2]",
    "section": "Building the server side",
    "text": "Building the server side\nWhen adjusting the server side of the game we need to make two things. First, we need to define the server() function for the app. Second, we need to adjust our functions of the hot_and_cold() game. In order to make things cleaner I keep all the game functions in an additional file app_functions.R and source() them at the top of the app script. It makes the script less cluttered with code and easier to work with because all that is left in the app is the shiny logic. We’ll start with defining the server() function and then make the adjustment in the game functions. For now, what matters is that we’ll have to package the entire state of the game (current coordinates, target coordinates, wall coordinates, number of moves, distance) in a single object (preferably in a list) to return in as a result of the game initiating function.\n\nThe server side\nThe general structure of the server side is pretty straightforward. We’ll start by rendering a welcome message that explains the rules of the game. Next we’ll have to create a logic to start the game with proper inputs. Finally we’ll define a logic for each movement which will also check if the game was won and display a winning message. Lets start by defining a welcome message:\n\n\nserver with welcome message\nserver &lt;- function(input, output) {\n  #Welcome message and rules\n  shinyalert(\"Welcome\", \"This is a hot & cold game\\nThe rules are:\n             You have to find the treasure. You can move by pressing up, down, left or right. Human icon shows your current position. You cant walk over walls. After each move the game will tell you if you are getting closer (Hot) or further (cold)\", type = \"info\", className = \"welcome\", animation=TRUE)\n}\n\n\nNow we need to define a logic that will start the game with given inputs. Since the game is initiated when the “play” button is pressed we need to use observeEvent() which listens to the specified button and executes given code if it is pressed. We’ll call our function to initialize the game get_game_grid() and it will take 3 arguments from our inputs. It returns a single list game_state which contains all information about a current state of the game. Next, we’ll render the output matrix (our game grid) with renderTable(). We’ll add one thing to the output to get rid of column names from the matrix.\n\n\nserver with start button logic\nserver &lt;- function(input, output) {\n  #Welcome message and rules\n  shinyalert(\"Welcome\", \"Hey hi hello! This is a hot & cold game\\nThe rules are:\n             You have to find the treasure. You can move by pressing\n             up, down, left or right. X shows your current position\n             You cant walk over walls which are shown with #\n             after each move the game will tell you if you are getting\n             closer (Hot) or further (cold)\", type = \"info\", className = \"welcome\", animation=TRUE)\n  \n  #initialize game when play pressed\n  observeEvent(input$play, {\n    game_state &lt;&lt;- get_game_grid(input$nrow, input$ncol, input$walls)\n    current_coord &lt;&lt;- game_state$current_coord\n    output$matrix &lt;- renderTable({\n      game_grid &lt;- game_state$game_grid \n    }, sanitize.text.function = function(x) x)\n  })\n}\n\n\nWe’ll use a very similar logic to define behavior of movement buttons. Each observeEvent() will listen to one movement button and execute the make_move() function with proper arguments when pressed. Next it will render the game grid again, extract the current and target coordinates to check if the game is won and display a winning message if it is.\n\n\nserver with movement logic\nserver &lt;- function(input, output) {\n  #Welcome message and rules\n  shinyalert(\"Welcome\", \"This is a hot & cold game\\nThe rules are:\n             You have to find the treasure. You can move by pressing up, down, left or right. Human icon shows your current position. You cant walk over walls. After each move the game will tell you if you are getting closer (Hot) or further (cold)\", type = \"info\", className = \"welcome\", animation=TRUE)\n  \n  #initialize game when play pressed\n  observeEvent(input$play, {\n    game_state &lt;&lt;- get_game_grid(input$nrow, input$ncol, input$walls)\n    current_coord &lt;&lt;- game_state$current_coord\n    output$matrix &lt;- renderTable({\n      game_grid &lt;- game_state$game_grid \n    }, sanitize.text.function = function(x) x)\n  })\n  \n  #Define movements when buttons are pressed\n  observeEvent(input$up, {\n    game_state &lt;&lt;- make_move(1,-1, game_state)\n    current_coord &lt;&lt;-game_state$current_coord\n    target_coord &lt;- game_state$target_coord\n    output$matrix &lt;- renderTable({\n      game_grid &lt;- game_state$game_grid\n    }, sanitize.text.function = function(x) x)\n    if ((target_coord[1] == current_coord[1] & target_coord[2] == current_coord[2])) {\n      shinyalert(paste0(\"Congratulations!\n                      You found the treasure in\", game_state$n_moves, ' moves'),type = \"success\")\n    }\n    \n  })\n  \n}\n\n\nNow we just need to create observeEvent() for each button with proper arguments in the make_move() function. The final version of the server side will look like this:\n\n\nfull server function\nserver &lt;- function(input, output) {\n  \n  #Welcome message and rules\n  shinyalert(\"Welcome\", \"This is a hot & cold game\\nThe rules are:\n             You have to find the treasure. You can move by pressing up, down, left or right. Human icon shows your current position. You cant walk over walls. After each move the game will tell you if you are getting closer (Hot) or further (cold)\", type = \"info\", className = \"welcome\", animation=TRUE)\n  \n  #initialize game when play pressed\n  observeEvent(input$play, {\n    game_state &lt;&lt;- get_game_grid(input$nrow, input$ncol, input$walls)\n    current_coord &lt;&lt;- game_state$current_coord\n    output$matrix &lt;- renderTable({\n      game_grid &lt;- game_state$game_grid \n    }, sanitize.text.function = function(x) x)\n  })\n\n  #Define movements when buttons are pressed\n  observeEvent(input$up, {\n    game_state &lt;&lt;- make_move(1,-1, game_state)\n    current_coord &lt;&lt;-game_state$current_coord\n    target_coord &lt;- game_state$target_coord\n    output$matrix &lt;- renderTable({\n      game_grid &lt;- game_state$game_grid\n    }, sanitize.text.function = function(x) x)\n    if ((target_coord[1] == current_coord[1] & target_coord[2] == current_coord[2])) {\n      shinyalert(paste0(\"Congratulations!\n                      You found the treasure in\", game_state$n_moves, ' moves'),type = \"success\")\n    }\n    \n  })\n    \n  observeEvent(input$down, {\n    game_state &lt;&lt;- make_move(1,1, game_state)\n    current_coord &lt;&lt;- game_state$current_coord\n    target_coord &lt;- game_state$target_coord\n    output$matrix &lt;- renderTable({\n      game_state$game_grid\n    }, sanitize.text.function = function(x) x)\n    if ((target_coord[1] == current_coord[1] & target_coord[2] == current_coord[2])) {\n      shinyalert(paste0(\"Congratulations!\n                      You found the treasure in\", game_state$n_moves, ' moves'),type = \"success\")\n    }\n\n  })\n  \n  observeEvent(input$right, {\n    game_state &lt;&lt;- make_move(2,1, game_state)\n    current_coord &lt;&lt;-game_state$current_coord\n    target_coord &lt;- game_state$target_coord\n    output$matrix &lt;- renderTable({\n      game_state$game_grid\n    }, sanitize.text.function = function(x) x)\n    if ((target_coord[1] == current_coord[1] & target_coord[2] == current_coord[2])) {\n      shinyalert(paste0(\"Congratulations!\n                      You found the treasure in\", game_state$n_moves, ' moves'),type = \"success\")\n    }\n\n  })\n  \n  observeEvent(input$left, {\n    game_state &lt;&lt;- make_move(2,-1, game_state)\n    current_coord &lt;&lt;-game_state$current_coord\n    target_coord &lt;- game_state$target_coord\n    output$matrix &lt;- renderTable({\n      game_state$game_grid\n    }, sanitize.text.function = function(x) x)\n    if ((target_coord[1] == current_coord[1] & target_coord[2] == current_coord[2])) {\n      shinyalert(paste0(\"Congratulations!\n                      You found the treasure in \", game_state$n_moves, ' moves'), type = \"success\")\n    }\n\n  })\n  \n}\n\n\n\n\nAdjusting internal functions\nWe need to split the game function into 2: one to initialize the game and a second function for making a move. This way one function will be called when the player presses the “play” button and another function will be called when the player makes a move. We’ll also need 3 additional files in a www folder to use in the game grid. We’ll call the function that initializes the game get_game_grid(). It should include all the stuff from our earlier game function until the initial game grid is drawn (so it defines the grid, creates starting, target and wall coordinates, performs necessary checks, calculates distance and initiates move counter). We need to make 2 changes to the function:\n\nwe want to return a whole list to keep the entire state of the game in one object that can then be passed as a single argument to the movement function. It’ll look like this:\n\nresult_list &lt;- list(nrow = nrow, ncol = ncol, game_grid = game_grid, \n                    start_coord = start_coord, target_coord = target_coord,\n                    current_coord = current_coord, walls_coords= walls_coords,\n                    old_distance = old_distance, new_distance = old_distance, n_moves =n_moves)\n\nwe can already include images instead of our X, - and # to make the grid look a little better. For now I quickly created simple graphics: player2.png, cell.png and wall.png in the www folder which we create in our project directory. I created mine in paint, no need to get fancier here (though you can if you want to!). You can find the exact images I used in the github repo of the app. We’ll keep all the checks and initial definitions with the original symbols just for the ease of use and rather include the images just before drawing the game grid which will look something like this:\n\n\nimages in the game grid\n  if(debug == FALSE) {\n    game_grid[target_coord[1], target_coord[2]] &lt;- '&lt;img src=\"cell.png\" style=\"display:flex; max-width:50%; height:auto\" /&gt;'\n  }\n\n  # player icon was adapted from https://commons.wikimedia.org/wiki/File:Running_icon_-_Noun_Project_17825.svg\n  # which is listed under Creative Commons 3.0 attribution license.\n  # Attribution goes to Dillon Arloff, from The Noun Project.\n  # The original icon was resized, had colors changed and the three horizontal lines deleted\n  game_grid[start_coord[1], start_coord[2]] &lt;- '&lt;img src=\"player2.png\" style=\"display:flex; max-width:50%; height:auto\" /&gt;'\n\n\n  for(i in walls_coords) {\n    game_grid[i[1],i[2]] &lt;- '&lt;img src=\"wall.png\" style=\"height:auto; width:auto; display:flex; max-width:50%; height:auto\" /&gt;'\n  }\n\n  game_grid[game_grid==\"-\"] &lt;- '&lt;img src=\"cell.png\" style=\"display:flex; max-width:50%; height:auto\" /&gt;'\n\n\nI also included some styling already that will help us get the grid to fit into the screen. Without it drawing a larger grid would make it larger than the screen and the game would be difficult to play.\nThe movement function will be used to make each move. We need to change a few things in the original movement function. First, we need make_move() function to include our earlier arguments that define if we move horizontally and if we add or subtract but now we need to include an additional argument - the game state. The game state is the result_list returned by get_game_grid() (and will also be returned by make_move()). Once we get the game state as argument the first thing we’ll do inside the function is unpack it to single elements that will be easier to work with later. At the end we will also pack everything back into a list and return it. Next, we need to change messages when some check is not passed (e.g. the player tries to walk pout of the grid) into notifications and then return the original game state. To create notifications just use shownotification(). Finally, just like in the get_game_grid() we need to use images instead of symbols in our game grid. The final version of the app_functions.R file is:\n\n\n\nfull game functions\nget_game_grid &lt;- function(nrow, ncol, n_walls, debug = FALSE) {\n  \n  game_grid &lt;- matrix(rep('-', nrow*ncol), nrow = nrow, ncol = ncol)\n  \n  #2 define target coordinates\n  obj_x &lt;- sample(1:nrow, 1)\n  obj_y &lt;- sample(1:ncol, 1)\n  target_coord &lt;- c(obj_x, obj_y)\n  \n  \n  #3define start coordinates\n  get_start_coord &lt;- function() {\n    start_x &lt;- sample(1:nrow, 1)\n    start_y &lt;- sample(1:ncol, 1)\n    start_coord &lt;- c(start_x, start_y)\n    \n    #check if start coordinates are not target coordinates\n    if (target_coord[1] == start_coord[1] & target_coord[2] == start_coord[2]) {\n      get_start_coord()\n    }\n    return(start_coord)\n  }\n  \n  start_coord &lt;- get_start_coord()\n  \n  #Create walls\n  create_walls &lt;- function() {\n    #define walls\n    \n    #create a grid of all coordinates\n    all_coords &lt;- expand.grid(1:nrow, 1:ncol)\n    \n    walls &lt;- do.call(`rbind`, sample(asplit(all_coords, 1), n_walls))\n    \n    walls_coords &lt;- split(walls, seq(nrow(walls)))\n    \n    return(walls_coords)\n  }\n  \n  walls_coords &lt;- create_walls()\n  \n  #Check if start or target coords are not on a wall\n  while((list(target_coord) %in% walls_coords) | (list(start_coord) %in% walls_coords)) {\n    walls_coords &lt;- create_walls()\n  }\n  \n  #BFS ALGORITHM TO CHECK IF GAME IS WINNABLE\n  is_valid_move &lt;- function(row, col, n, p, visited) {\n    # Check if the cell is within the bounds of the matrix\n    if (row &lt; 1 || row &gt; n || col &lt; 1 || col &gt; p) {\n      return(FALSE)\n    }\n    \n    # Check if the cell has already been visited\n    if (visited[row, col]) {\n      return(FALSE)\n    }\n    \n    # Check if the cell is valid (i.e., contains \"-\", \"X\", or \"T\")\n    if (!(game_grid[row, col] %in% c(\"-\", \"X\", \"T\"))) {\n      return(FALSE)\n    }\n    \n    # If all conditions are satisfied, the move is valid\n    return(TRUE)\n  }\n  \n  # Define the function to find a path between \"X\" and \"T\"\n  find_path &lt;- function(game_grid) {\n    # Define the start and end cells\n    start_row &lt;- which(game_grid == \"X\", arr.ind = TRUE)[1]\n    start_col &lt;- which(game_grid == \"X\", arr.ind = TRUE)[2]\n    end_row &lt;- which(game_grid == \"T\", arr.ind = TRUE)[1]\n    end_col &lt;- which(game_grid == \"T\", arr.ind = TRUE)[2]\n    \n    # Define the queue and visited matrix\n    queue &lt;- list()\n    visited &lt;- matrix(FALSE, nrow = nrow(game_grid), ncol = ncol(game_grid))\n    \n    # Add the start cell to the queue\n    queue[[1]] &lt;- c(start_row, start_col, 0)\n    \n    # Loop until the queue is empty\n    while (length(queue) &gt; 0) {\n      # Get the first cell in the queue\n      curr_cell &lt;- unlist(queue[[1]])\n      curr_row &lt;- curr_cell[1]\n      curr_col &lt;- curr_cell[2]\n      curr_dist &lt;- curr_cell[3]\n      \n      # Remove the first cell from the queue\n      queue &lt;- queue[-1]\n      \n      # Mark the cell as visited\n      visited[curr_row, curr_col] &lt;- TRUE\n      \n      # Check if the current cell is the end cell\n      if (curr_row == end_row && curr_col == end_col) {\n        # Return the distance from the start cell to the end cell\n        return(curr_dist)\n      }\n      \n      # Check the neighboring cells\n      neighbor_cells &lt;- list(c(curr_row - 1, curr_col), c(curr_row + 1, curr_col), \n                             c(curr_row, curr_col - 1), c(curr_row, curr_col + 1))\n      for (neighbor_cell in neighbor_cells) {\n        neighbor_row &lt;- neighbor_cell[1]\n        neighbor_col &lt;- neighbor_cell[2]\n        \n        if (is_valid_move(neighbor_row, neighbor_col, nrow(game_grid), ncol(game_grid), visited)) {\n          # Add the neighboring cell to the queue\n          queue[[length(queue) + 1]] &lt;- c(neighbor_row, neighbor_col, curr_dist + 1)\n        }\n      }\n    }\n    \n    # If no path is found, return FALSE\n    return(FALSE)\n  }\n  #add a check that there exists a path! We'll need the BFS for this\n  \n  \n  #display the first grid and instructions\n  #change elements of grid to walls:\n  for(i in walls_coords) {\n    game_grid[i[1],i[2]] &lt;- '#'\n  }\n  \n  game_grid[start_coord[1], start_coord[2]] &lt;- 'X'\n  game_grid[target_coord[1], target_coord[2]] &lt;- 'T'\n  \n  bfs_result &lt;- find_path(game_grid)\n  \n  while(!bfs_result | (list(target_coord) %in% walls_coords) | (list(start_coord) %in% walls_coords)) {\n    #regenerate walls\n    walls_coords &lt;- create_walls()\n    game_grid &lt;- matrix(rep('-', nrow*ncol), nrow = nrow, ncol = ncol)\n    for(i in walls_coords) {\n      game_grid[i[1],i[2]] &lt;- '#'\n    }\n    \n    game_grid[start_coord[1], start_coord[2]] &lt;- 'X'\n    game_grid[target_coord[1], target_coord[2]] &lt;- 'T'\n    bfs_result &lt;- find_path(game_grid)\n    \n  }\n  \n  if(debug == FALSE) {\n    game_grid[target_coord[1], target_coord[2]] &lt;- '&lt;img src=\"cell.png\" style=\"display:flex; max-width:50%; height:auto\" /&gt;'\n  }\n  \n   # player icon was adapted from https://commons.wikimedia.org/wiki/File:Running_icon_-_Noun_Project_17825.svg\n  # which is listed under Creative Commons 3.0 attribution license.\n  # Attribution goes to Dillon Arloff, from The Noun Project.\n  # The original icon was resized, had colors changed and the three horizontal lines deleted\n  \n  game_grid[start_coord[1], start_coord[2]] &lt;- '&lt;img src=\"player2.png\" style=\"display:flex; max-width:50%; height:auto\" /&gt;'\n  \n  \n  for(i in walls_coords) {\n    game_grid[i[1],i[2]] &lt;- '&lt;img src=\"wall.png\" style=\"height:auto; width:auto; display:flex; max-width:50%; height:auto\" /&gt;'\n  }\n  \n  game_grid[game_grid==\"-\"] &lt;- '&lt;img src=\"cell.png\" style=\"display:flex; max-width:50%; height:auto\" /&gt;'\n  \n  #set current coordinates\n  current_coord &lt;- start_coord\n  \n  #calculate distance as Manhattan\n  \n  old_distance &lt;- sum(abs(target_coord[1] - current_coord[1]),abs(target_coord[2] - current_coord[2]))\n  \n  #initiate move counter\n  \n  n_moves &lt;- 1\n  \n  \n  result_list &lt;- list(nrow = nrow, ncol = ncol, game_grid = game_grid, start_coord = start_coord, target_coord = target_coord,\n                      current_coord = current_coord, walls_coords= walls_coords, old_distance = old_distance, new_distance = old_distance,\n                      n_moves =n_moves)\n  \n  return(result_list)\n}\n\n\nmake_move &lt;- function(h, add, game_state) {\n  \n  \n  #unpack game state\n  nrow &lt;- game_state$nrow\n  ncol &lt;- game_state$ncol\n  start_coord &lt;- game_state$start_coord\n  target_coord &lt;- game_state$target_coord\n  current_coord &lt;- game_state$current_coord\n  old_distance &lt;- game_state$old_distance\n  new_distance &lt;- game_state$new_distance\n  walls_coords &lt;- game_state$walls_coords\n  n_moves &lt;- game_state$n_moves\n  game_grid &lt;- game_state$game_grid\n  \n  \n  if (h == 1 & add == 1) {\n    if (current_coord[h] + add &gt; nrow) {\n      showNotification('You cant move there!')\n      return(game_state) # this will force R to move to the next iteration of the loop\n    } \n    if (list(as.integer(c(current_coord[1]+ add,current_coord[2] ))) %in% walls_coords) {\n      #check if you walk on a wall\n      showNotification('You cant move there!')\n      return(game_state)\n    }\n  } else if (h == 1 & add==-1) {\n    if (current_coord[h] + add &lt; 1) {\n      showNotification('You cant move there!')\n      return(game_state) # this will force R to move to the next iteration of the loop\n    } \n    if (list(as.integer(c(current_coord[1] + add,current_coord[2]))) %in% walls_coords) {\n      #check if you walk on a wall\n      showNotification('You cant move there!')\n      return(game_state)\n    }\n    \n  } else if (h == 2 & add==1) {\n    if (current_coord[h] + add &gt; ncol) {\n      showNotification('You cant move there!')\n      return(game_state) # this will force R to move to the next iteration of the loop\n    } \n    if (list(as.integer(c(current_coord[1],current_coord[2]+ add))) %in% walls_coords) {\n      #check if you walk on a wall\n      showNotification('You cant move there!')\n      return(game_state)\n    }\n    \n  } else if (h == 2 & add==-1) {\n    if (current_coord[h] + add &lt; 1) {\n      showNotification('You cant move there!')\n      return(game_state) # this will force R to move to the next iteration of the loop\n    } \n    if (list(as.integer(c(current_coord[1] ,current_coord[2]+ add))) %in% walls_coords) {\n      #check if you walk on a wall\n      showNotification('You cant move there!')\n      return(game_state)\n    }\n  }\n  \n  \n  #update grid and coords\n  game_grid[current_coord[1], current_coord[2]] &lt;- '&lt;img src=\"cell.png\" style=\"display:flex; max-width:30%; height:auto\" /&gt;'\n  current_coord[h] &lt;- current_coord[h] + add\n  game_grid[current_coord[1], current_coord[2]] &lt;- '&lt;img src=\"player2.png\" style=\"display:flex; max-width:30%; height:auto\" /&gt;'\n  \n  #update distance and number of moves\n  new_distance &lt;- sum(abs(target_coord[1] - current_coord[1]),abs(target_coord[2] - current_coord[2]))\n  n_moves &lt;- n_moves + 1\n  \n  #display message\n  if(new_distance &lt; old_distance) {\n    showNotification('Hotter!', type = 'warning')\n  } else if (new_distance &gt; old_distance) {\n    showNotification('Colder!', type = 'error')\n  }\n  #update distance\n  old_distance &lt;- new_distance\n  #print grid and make next move\n  \n  result_list &lt;- list(nrow = nrow, ncol = ncol, game_grid = game_grid, start_coord = start_coord, target_coord = target_coord,\n                                    current_coord = current_coord, old_distance = old_distance, new_distance = old_distance,\n                                    n_moves =n_moves, walls_coords = walls_coords)\n  \n  return(result_list)\n  \n}\n\n\nJust add source(app_functions.R) at the top of the app script to load the game functions."
  },
  {
    "objectID": "posts/first-game-2/index.html#styling-the-app",
    "href": "posts/first-game-2/index.html#styling-the-app",
    "title": "Make a game in R - shiny [part 2]",
    "section": "Styling the app",
    "text": "Styling the app\nOk, we have a working version of the game! However, it still does not look great. The last thing we need to do before launching it is to make it look better. We’ll just add a css file that will define some fonts, colors etc. Lets call the file style.css and put it in the project directory but if you want to go really fancy with it you can look for more information here. To load the style add includeCSS(\"style.css\") inside the fluidPage() in the ui. We’ll start by defining the fonts and general colors. The import statement loads a proper google font. and the * statement defines general colors and font.\nGenerally we change the look of 2 other things: all the buttons, notifications and inputs are styled to have the same dark background and the same font. We also defined different color for hovering over the buttons. The notifications were a bit tricky because it was hard to find their css classes (they are defined from .welcome to .shiny-notification in the code below). The other thing we need to change is how the game grid looks like. Recall that it is rendered as a table with images in each cell. The tricky thing is that the table has varying number of rows and columns and we want it to fit the screen and resize all the images to fit the table. We also want to get rid of all the spacing and borders between the cells (we only keep borders around the entire table). The table is defined from table to the end of the code chunk below. Honestly I have very little experience with css and some of the code below may be redundant but it works and it took me so long to get it ok that for now I’m willing to leave it as is.\n\n\ncss code\n@import url('https://fonts.googleapis.com/css?family=Share+Tech+Mono&display=swap');\n\n*{\n  font-family: \"Share Tech Mono\";\n  color: #66FF00;\n  background-color: #001219;\n}\n\nh2{\n  font-size: 5em;\n}\n\nbody{\n  color: #66FF00;\n  background-color: #001219;\n}\n\n#sidebar{ \n  color: #66FF00;\n  background-color: #001219;\n  border-color: #66FF00;\n  font-size: 2.5em;\n}\n\n.form-control{\n  color: #66FF00;\n  background-color: #001219;\n  border-color: #66FF00;\n    font-size: 1em;\n}\n\n.btn{\n  color: #66FF00;\n  background-color: #001219;\n}\n\n.btn:hover{\n  color: #66FF00;\n  background-color: #264653;\n}\n\n.welcome{\n  color: #66FF00;\n  background-color: #001219;\n  font-size: 1.5em;\n}\n\n.win{\n  font-family: \"Share Tech Mono\";\n  color: #66FF00;\n  background-color: #001219;\n  font-size: 1.5em;\n}\n\n.alert{\n  color: #66FF00;\n  background-color: #001219;\n  !important;\n}\n\n.confirm{\n  color: #66FF00;\n  background-color: #001219;\n  !important;\n}\n\n.shiny-notification{\n  font-family: \"Share Tech Mono\";\n  color: #66FF00;\n  background-color: #001219;\n}\n\ntable{\n  table-layout:fixed;\n  height: 70%;\n  width: 90%;\n  border-style: solid;\n  border-color: #66FF00;\n  \n}\n\n#matrix td {\n  border-color: #66FF00;\n  aspect-ratio: 1 / 1;\n  max-height: 100%;\n  max-width: 100%;\n  padding: 0px; \n  margin: 0px; \n  border: 0px;\n  align-content: center;\n}\n\n#matrix th {\n  display: none;\n}\n\nimg {\n   max-width:100%;\n   vertical-align: bottom;\n   height:auto;\n   display:block;\n}"
  },
  {
    "objectID": "posts/first-game-2/index.html#final-tweaks",
    "href": "posts/first-game-2/index.html#final-tweaks",
    "title": "Make a game in R - shiny [part 2]",
    "section": "Final tweaks",
    "text": "Final tweaks\nThere are some tweaks you can make to the game if you want at this point. e.g. in the final version I changed Manhattan distance to Euclidean which I think makes the game a bit more difficult. You just need to change how current_distance is calculated."
  },
  {
    "objectID": "posts/first-game-2/index.html#launching-the-app",
    "href": "posts/first-game-2/index.html#launching-the-app",
    "title": "Make a game in R - shiny [part 2]",
    "section": "Launching the app",
    "text": "Launching the app\nOk, now we’re ready to go! You can run the shinyapp(ui,server) function to see your working game!.\nA working version of the game can also be accessed here. The code is stored in my github repository here.\nThe image used in the post thumbnail is taken from https://unsplash.com/photos/A_Z–0ey4HQ."
  },
  {
    "objectID": "research.html",
    "href": "research.html",
    "title": "Research",
    "section": "",
    "text": "I am mainly interested in the intersection of psychology of language, emotions and intergroup relations"
  },
  {
    "objectID": "research.html#papers",
    "href": "research.html#papers",
    "title": "Research",
    "section": "Papers",
    "text": "Papers\n\nWypych, M., & Bilewicz, M. (2022). Psychological toll of hate speech: The role of acculturation stress in the effects of exposure to ethnic slurs on mental health among Ukrainian immigrants in Poland. Cultural Diversity and Ethnic Minority Psychology. Advance online publication. https://doi.org/10.1037/cdp0000522\nBabińska, M., Bilewicz, M., Górska, P., Toruńczyk-Ruiz, S., & Wypych, M. (2022). Poles toward Ukrainians: The results of survey studies. NAUKA, (4). http://www.nauka-pan.pl/index.php/nauka/article/view/982\nWypych, M., Zochniak, K., & Bilewicz, M. (2020). Mowa nienawiści jako stygmatyzacja. Doświadczenie kontaktu z mową nienawiści wśród imigrantów w Polsce oraz studentów z zagranicy. Kultura i Społeczeństwo, 64(3), 199-219. https://www.ceeol.com/search/article-detail?id=986670\nHansen, K., Wypych, M., Bańko, M., & Bilewicz, M. (2018). Psychological Determinants of Linguistic Purism: National Identification, Conservatism, and Attitudes to Loanwords. Journal of Language and Social Psychology, 37(3), 365–375. https://doi.org/10.1177/0261927X17737810"
  },
  {
    "objectID": "teaching.html",
    "href": "teaching.html",
    "title": "Teaching",
    "section": "",
    "text": "I teach 2 courses:\n\nSocial Psychology seminar\nIntroduction to R. I’m in the process of developing a website for the course which will be linked shortly"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Michał Wypych",
    "section": "",
    "text": "I’m Michał. I’m a social psychologist especially interested in emotions and language. I’m also passionate about R, data vizualisation and analysis. I teach an introduction to R course at Faculty of Psychology at University of Warsaw."
  },
  {
    "objectID": "drafts/percentile_scales.html",
    "href": "drafts/percentile_scales.html",
    "title": "A few remarks on percentile scales",
    "section": "",
    "text": "So this\nWhat to show in the post:\nBelow is the setup chunk with some functions for plots and loaded packages\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(dplyr)\n\n\nDołączanie pakietu: 'dplyr'\n\n\nNastępujące obiekty zostały zakryte z 'package:stats':\n\n    filter, lag\n\n\nNastępujące obiekty zostały zakryte z 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(showtext)\n\nŁadowanie wymaganego pakietu: sysfonts\n\n\nŁadowanie wymaganego pakietu: showtextdb\n\nfont_add_google(\"Lato\")\nfont_add_google(\"Ubuntu\")\nshowtext_auto()\n\n\ncol_main &lt;- c(\"darkred\", \"firebrick3\", \"coral1\", \"salmon\",\"rosybrown3\",\"palevioletred1\", \"plum4\", \"purple2\",\"springgreen2\", \"seagreen\",\"skyblue\", \"turquoise4\", \"steelblue4\", \"royalblue3\", \"slateblue4\", \"navyblue\" )\n\n\n\nmy_theme &lt;- function() {\n  #requires Lato and Ubuntu fonts\n  theme_minimal(base_family = \"Lato\", base_size = 20) +\n    theme(panel.grid.minor = element_blank(),\n          plot.background = element_rect(fill = \"white\", color = NA),\n          plot.title = element_text(face = \"bold\", size = 30, family = \"Ubuntu\"),\n          plot.subtitle = element_text(size = 20),\n          axis.title = element_text(face = \"bold\"),\n          strip.text = element_text(face = \"bold\"),\n          strip.background = element_rect(fill = \"grey80\", color = NA),\n          legend.title = element_text(face = \"bold\"),\n          plot.title.position = \"plot\")\n}\nFirst lets get some data in.\n#' lets start with some simulation\n\nN &lt;- 1e4\nx &lt;- rnorm(N)\n\nx_perc &lt;- ntile(x, 100)"
  },
  {
    "objectID": "drafts/percentile_scales.html#looking-at-marginal-distributions",
    "href": "drafts/percentile_scales.html#looking-at-marginal-distributions",
    "title": "A few remarks on percentile scales",
    "section": "looking at marginal distributions",
    "text": "looking at marginal distributions\n\nchanging original distribution"
  },
  {
    "objectID": "drafts/percentile_scales.html#spacing-between-percentiles",
    "href": "drafts/percentile_scales.html#spacing-between-percentiles",
    "title": "A few remarks on percentile scales",
    "section": "Spacing between percentiles",
    "text": "Spacing between percentiles\nOne thing that is often forgotten about the percentile scales is that there can be different spacings between various percentiles. Lets calculate the values for percentiles and then get differences between subsequent percentiles to look at this:\n\nx_percentiles &lt;- quantile(x, probs = seq(.01, 1, .01))\n\nx_df &lt;- data.frame(x_percentiles) %&gt;%\n  mutate(perc_lag = lag(x_percentiles),\n         difference_1 = x_percentiles - perc_lag)\n\nx_df %&gt;%\n  drop_na() %&gt;%\n  ggplot(aes(x = 2:100, y = difference_1)) +\n  geom_point(color = col_main[12]) +\n  labs(x = NULL, y = \"difference\") +\n  my_theme()\n\n\n\n\n\n\n\n\nYou can see that the differences are quite large for the first few and last few percentiles and are pretty small for the rest. This is exactly what we would expect with a gaussian original distribution\nLets try to overlay the percentiles on the gaussian distribution we drew our data from\n\nas.data.frame(x) |&gt;\n  ggplot(aes(x)) +\n  geom_density(color = col_main[13], linewidth = 2) +\n  geom_vline(data = x_df, aes(xintercept = x_percentiles), color = col_main[12]) +\n  labs(title = \"Spacing of percentiles\", subtitle = \"Original distribution (thick red line) has percentiles\\noverlayed as vertical lines (pink)\") +\n  my_theme()\n\n\n\n\n\n\n\n\nYou can see how much of the distribution falls into 1st, 2nd or 99th percentile and how little falls into a single percentile in the middle of the distribution. It’s actually fairly intuitive why this happens. The same number of people have to fall into each percentile and if there are few people at the tails of the distribution then we need to widen the range of the percentiles there to get enough people. The opposite is true for the peak of the distribution. There are a lot of people there so slim sliver of the distribution is enough to get quite a few people into the percentile. The fact that someone falls into low/high percentile doe\nThis also means that if some value increases over time from a very low percentile with a steady pace then we might expect first slow increases in percentiles, then rapid increases around the middle of the distribution and again slower increases as we are reaching the top. Lets try simulating that:\n\n#' generate initial small x\n#' run a for loop in which we:\n#' - increase the value of x\n#' - record its percentile now and save it\n#' - store percentile for each step\n#' \n\nx_init &lt;- min(x) #start with the lowest value in our distribution\nperc_progress &lt;- c() #create a vector to store percentiles\nfor(i in 1:1000) { # max of 1000 steps\n  x_init &lt;- x_init + .1 #increase our value by .1\n  perc_value &lt;- min(x_percentiles[which(x_percentiles &gt; x_init)]) # get the percentile value\n  percentile &lt;- names(x_percentiles[which(x_percentiles == perc_value)]) # get the percentile name\n  perc_progress &lt;- c(perc_progress, percentile) # we want to stop if we get too close to max value and there are still iterations left (otherwise the min() function breaks)\n  if (x_init &gt;=(max(x) - .1)) {\n    break\n  }\n}\n\nperc_progress&lt;- as.numeric(str_extract(perc_progress, \"[0-9]+\"))\n\ndata.frame(perc_progress) %&gt;%\n  ggplot(aes(x = 1:length(perc_progress), y = perc_progress)) +\n  geom_line(color = col_main[12], linewidth = 2) +\n  labs(x = \"iteration\", y = \"percentile\") +\n  my_theme()\n\n\n\n\n\n\n\n\nExactly what we would expect! First the change in percentiles is slow, then it speeds up and slows down in the right half of the plot. It takes us a long time to get out of the lowest percentiles but once we do we quickly get to the 50th and start changing more slowly form there on.\n\nvariability in percentiles\nOne significant consequence of how differences between subsequent percentiles vary is how much variability in percentiles can we expect with the same amount of variability on the original scale depending on where we start.\nThis is a common thing when infants gain weight. They might be gaining weight by some amount plus some random variations (lots of reasons here - some things in the diet, baby pooped/peed before being weighed etc.). In low or high percentiles we might expect this random variation in how much they gain weight to matter little. However in the middle it will make the variation in percentiles seem bigger. Again lets simulate some random variation around our distribution of x with 3 starting places: low (5th), middle (50th) and high percentile (95th).\n\nsimulate_variability &lt;- function(init_perc, sd_change) {\n  x_init &lt;- x_percentiles[init_perc] #start with the lowest value in our distribution\nperc_progress &lt;- c() #create a vector to store percentiles\nfor(i in 1:1000) { # max of 1000 steps\n  x_init &lt;- x_init + rnorm(1, mean = 0, sd = sd_change) #increase our value by .1\n  perc_value &lt;- min(x_percentiles[which(x_percentiles &gt; x_init)]) # get the percentile value\n  percentile &lt;- names(x_percentiles[which(x_percentiles == perc_value)]) # get the percentile name\n  perc_progress &lt;- c(perc_progress, percentile) # we want to stop if we get too close to max value and there are still iterations left (otherwise the min() function breaks)\n  if (x_init &gt;=(max(x) - .1) | x_init &lt;= (min(x) + .1)) {\n    break\n  }\n}\n  perc_progress&lt;- as.numeric(str_extract(perc_progress, \"[0-9]+\"))\n  return(perc_progress)\n}\n\n\nprog_low &lt;- simulate_variability(5, .02)\nprog_mid &lt;- simulate_variability(50, .02)\nprog_high &lt;- simulate_variability(95, .02)\n\nprog_df &lt;- data.frame(prog_low, prog_mid, prog_high) %&gt;%\n  pivot_longer(cols = everything(), values_to = \"percentile\", names_to = \"condition\") %&gt;%\n  mutate(condition = factor(condition, ordered = T, levels = c(\"prog_low\", \"prog_mid\", \"prog_high\")))\n\n\nprog_df %&gt;%\n  ggplot(aes(x = 1:length(percentile)/3, y = percentile)) +\n  geom_line(color = col_main[12]) +\n  facet_wrap(~condition) +\n  labs(x = \"iteration\", y = \"percentile\") +\n  my_theme()\n\n\n\n\n\n\n\n\nYou can see a lot more variability in the middle panel than in the left or right ones even though the changes on the original scale come from the same distribution.\nIn the above simulation we were in fact not creating any growth, just random variation from the original value (in order to simulate that we would need percentiles for each iteration) but assuming no strange growths that would not change the results a lot (rather than drawing a number from a distribution with mean 0 we would make the mean higher than 0 and still our expectation would be that a person in 50th percentile in time 1 should be on average in 50th percentile in time 2).\nThis means that when looking at percentiles e.g. weight gains of babies in low or high percentiles might seem much more stable than of those from the mid percentiles even if in fact they are very similar weight gains."
  },
  {
    "objectID": "drafts/percentile_scales.html#correlations-with-percentiles",
    "href": "drafts/percentile_scales.html#correlations-with-percentiles",
    "title": "A few remarks on percentile scales",
    "section": "Correlations with percentiles",
    "text": "Correlations with percentiles\nThe last thing worth looking at when working with percentile scales are some unintuitive things about correlations on percentile scales.\n\ny &lt;- rnorm(N, .6*x)\n\ny_perc &lt;- ntile(y, 100)\n\nd &lt;- data.frame(x, y, x_perc, y_perc)\n\nLets start by looking at a simple scatterplot:\n\nd |&gt;\n  ggplot(aes(x = x, y = y)) +\n  geom_point(alpha = .3) +\n  labs(title = paste0(\"correlation = \",as.character(round(cor(x, y), 2)))) +\n  my_theme()\n\n\n\n\n\n\n\n\nNow lets look at the percentiles:\n\nd |&gt;\n  ggplot(aes(x = x_perc, y = y_perc)) +\n  geom_point(alpha = .3) +\n  labs(title = paste0(\"correlation = \",as.character(round(cor(x_perc, y_perc), 2)))) +\n  my_theme()\n\n\n\n\n\n\n\n\nlooks a loot more noisy right? But the correlation is pretty much the same. This can be pretty confusing and is actually sometimes done in those “guess the correlation from the scatterplot” games.\nDo I want to add some transformations and how they affect correlations?\nlets try some additional weirder stuff\n\nx_moved &lt;- x + .5\nx_m_perc &lt;- ntile(x_moved, 100)\n\nplot(x_moved, y)\n\n\n\n\n\n\n\n\n\nx_scaled &lt;- x^2\nx_s_perc &lt;- ntile(x_scaled, 100)\n\ncor(x_s_perc, y_perc)\n\n[1] -0.01078776\n\ncor(x_scaled, y)\n\n[1] -0.009259721"
  },
  {
    "objectID": "portfolio/parks/index.html",
    "href": "portfolio/parks/index.html",
    "title": "National Parks in the USA",
    "section": "",
    "text": "by Michał Wypych\n\n\n\n\n The National Park System in the USA is in charge of caring for the 63 national parks located in the USA. National Parks differ in the kinds of environment, landscape, animals and plants they have preserved. This presentation focuses on 15 parks with data available from Tidytuesday. You can see the map of parks here.\n\n\n\n\nThere are many species, many parks and unfortunately lots of missing information. We have the most information on amphibias, birds, fish, mammals, reptiles and vascular plants. There is little information on presence of bacteria, chromista nad protozoa in those parks\nAll information on the parks taken from the National Park Service and the data was taken from Tidytuesday week 41 2024"
  },
  {
    "objectID": "portfolio/parks/index.html#sec-acadia",
    "href": "portfolio/parks/index.html#sec-acadia",
    "title": "National Parks in the USA",
    "section": "Acadia National Park",
    "text": "Acadia National Park\nThe park lies in the North East of the USA, in Maine. It is situated along the Atlantic coastline. It contains mountains, lakes, forests and coastlines which contribute to the diversity of its fauna and flora. There is a lot of confirmed Fish and Amphibians in this park. The lands that are now part of the park have been inhabited over 12 000 years ago."
  },
  {
    "objectID": "portfolio/parks/index.html#bryce",
    "href": "portfolio/parks/index.html#bryce",
    "title": "National Parks in the USA",
    "section": "Bryce Canyon National Park",
    "text": "Bryce Canyon National Park\nThis park lies in southern Utah. Since it’s a mountain park (it spans over 650 meters!) there is only 1 species of fish present but has a large diversity ofd plants and birds. It is famous for its spire rocks."
  },
  {
    "objectID": "portfolio/parks/index.html#cuyahoga",
    "href": "portfolio/parks/index.html#cuyahoga",
    "title": "National Parks in the USA",
    "section": "Cuyahoga Valley National Park",
    "text": "Cuyahoga Valley National Park\nThis park lies close to Cleveland and Lake Erie. It is based around river Cuyahoga which provides it with a large diversity of categories of animals and plants."
  },
  {
    "objectID": "portfolio/parks/index.html#glacier",
    "href": "portfolio/parks/index.html#glacier",
    "title": "National Parks in the USA",
    "section": "Glacier National Park",
    "text": "Glacier National Park\nThe park is located in the very north of Montana close to the border with Canada. It is a host for multiple species of plants and mammals that thrive in the alpine climate"
  },
  {
    "objectID": "portfolio/parks/index.html#canyon",
    "href": "portfolio/parks/index.html#canyon",
    "title": "National Parks in the USA",
    "section": "Grand Canyon National Park",
    "text": "Grand Canyon National Park\nThis park is probably one of the best known national parks in the USA. Located west of Las Vegas in Nevada it is famous for the breathtaking views of canyons up to 6000 feet deep but also for a large variety of plants and birds."
  },
  {
    "objectID": "portfolio/parks/index.html#teton",
    "href": "portfolio/parks/index.html#teton",
    "title": "National Parks in the USA",
    "section": "Grand Teton National Park",
    "text": "Grand Teton National Park\nThis park is in northwestern Wyoming. This mountain-based park has a cold and snowy climate is the host for such species like Grizzly Bears and bull moose. It has beautiful glaciers, creeks, lakes and hot springs."
  },
  {
    "objectID": "portfolio/parks/index.html#smoky",
    "href": "portfolio/parks/index.html#smoky",
    "title": "National Parks in the USA",
    "section": "Great Smoky Mountains National Park",
    "text": "Great Smoky Mountains National Park\nThis park is located in North Carolina has the largest number of insects, spiders and fungi out of all national parks described here. It has also a huge variety of other categories of living organisms making it the most biodiverse park in thew National Park System. Its mountain temperate climate and humid weather with abundance of rain make it possible for such diversity of organisms to live there"
  },
  {
    "objectID": "portfolio/parks/index.html#springs",
    "href": "portfolio/parks/index.html#springs",
    "title": "National Parks in the USA",
    "section": "Hot Springs National Park",
    "text": "Hot Springs National Park\nAs the name suggests the Hot Springs National Park is famous for its thermal springs and historic bathhouses. It does not have as many confirmed plant occurrences as the other parks. Located next to Hot springs in Arkansas the park is surrounded by mountians and forests. Unfortunately many species were lost due to hunting and loss of habitat before the park was expanded to protect the fauna and flora of the region."
  },
  {
    "objectID": "portfolio/parks/index.html#dunes",
    "href": "portfolio/parks/index.html#dunes",
    "title": "National Parks in the USA",
    "section": "Indiana Dunes National Park",
    "text": "Indiana Dunes National Park\nThis park is located by Lake Michigan in northern USA. It is best known for its shoreline and dunes that are host for many plants and bird species. It has fourth highest biodiversity among the national parks."
  },
  {
    "objectID": "portfolio/parks/index.html#joshua",
    "href": "portfolio/parks/index.html#joshua",
    "title": "National Parks in the USA",
    "section": "Joshua Tree National Park",
    "text": "Joshua Tree National Park\nThis park is located close to Palm springs in California between Colorado Desert, Mojave Desert and Little San Bernardino Mountains. Many species of birds can be sighted there because it lies on the Pacific flyway for migratory birds."
  },
  {
    "objectID": "portfolio/parks/index.html#olympic",
    "href": "portfolio/parks/index.html#olympic",
    "title": "National Parks in the USA",
    "section": "Olympic National Park",
    "text": "Olympic National Park\nIn the far north west of USA lies the Olympic National Park. Located east of Seattle it comprises of mountains with glaciers, temperate rain forests and a long wild coastline. It is home to many plant and mammal species as well as insects and fish. Dolphins, sea lions and even whales can be spotted from its shores."
  },
  {
    "objectID": "portfolio/parks/index.html#rocky",
    "href": "portfolio/parks/index.html#rocky",
    "title": "National Parks in the USA",
    "section": "Rocky Mountain National Park",
    "text": "Rocky Mountain National Park\nThis park lies close to Denver in Colorado. It’s elevation (from 7,860 feet to 14,259 feet) defines the unique features of this park, from large meadows to alpine lakes. It has a large variety of categories of living organisms with many plants, fungi and insects present."
  },
  {
    "objectID": "portfolio/parks/index.html#yellowstone",
    "href": "portfolio/parks/index.html#yellowstone",
    "title": "National Parks in the USA",
    "section": "Yellowstone National Park",
    "text": "Yellowstone National Park\nThis park is famous for its geysers and other hydrothermal areas. It is located in north western Wyoming. Its unique climate is home to a huge variety of insects and plants, especially thermophiles. Thanks to having been established early in the US history it was able to protect its varied wildlife."
  },
  {
    "objectID": "portfolio/parks/index.html#yosemite",
    "href": "portfolio/parks/index.html#yosemite",
    "title": "National Parks in the USA",
    "section": "Yosemite National Park",
    "text": "Yosemite National Park\nThis park is located in California, over 200 kilometers east of San Francisco. It is most famous for its waterfalls, valleys and meadows. It is home to giant sequoias and over 1000 species of other plants."
  },
  {
    "objectID": "portfolio/parks/index.html#zion",
    "href": "portfolio/parks/index.html#zion",
    "title": "National Parks in the USA",
    "section": "Zion National Park",
    "text": "Zion National Park\nThis park is located in southwestern Utah. Its large elevation change with over 5000 feet in the highest point it provides diverse habitats for many species of plants and animals. The meandering canyons and rivers are home to many plants and birds."
  },
  {
    "objectID": "portfolio/apps/index.html",
    "href": "portfolio/apps/index.html",
    "title": "Applications",
    "section": "",
    "text": "Here are some of the shiny apps I made."
  },
  {
    "objectID": "portfolio/apps/index.html#average-wages-on-county-level-in-poland",
    "href": "portfolio/apps/index.html#average-wages-on-county-level-in-poland",
    "title": "Applications",
    "section": "Average wages on county level in Poland",
    "text": "Average wages on county level in Poland\nThis is a shiny app that takes data from the Polish General Office of Statistics. It displays average wages on county levels from 2002 to 2023.\nThe app can be accessed here: https://micwypych-guswages.share.connect.posit.cloud/"
  },
  {
    "objectID": "posts/percentiles/index.html",
    "href": "posts/percentiles/index.html",
    "title": "A few remarks on percentile scales",
    "section": "",
    "text": "So this post was born out of annoyance with dealing with percentile grids for baby weights and how easily they are misunderstood. What I want to show are some more or less unintuitive features of percentiles scales especially having to do with how the distribution for percentiles looks like and how spacing between percentiles affects potential variability (e.g. in change) depending on where we are on the percentile scale.\nBelow is the setup chunk with some functions for plots and loaded packages\nsetup\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(showtext)\nlibrary(patchwork)\n\nfont_add_google(\"Lato\")\nfont_add_google(\"Ubuntu\")\nshowtext_auto()\n\n\ncol_main &lt;- c(\"darkred\", \"firebrick3\", \"coral1\", \"salmon\",\"rosybrown3\",\"palevioletred1\", \"plum4\",\"slateblue4\", \"purple2\",\"springgreen2\", \"seagreen\",\"skyblue\", \"turquoise4\", \"steelblue4\", \"royalblue3\", \"navyblue\" )\n\n\n\nmy_theme &lt;- function() {\n  #requires Lato and Ubuntu fonts\n  theme_minimal(base_family = \"Lato\", base_size = 20) +\n    theme(panel.grid.minor = element_blank(),\n          plot.background = element_rect(fill = \"white\", color = NA),\n          plot.title = element_text(face = \"bold\", size = 30, family = \"Ubuntu\"),\n          plot.subtitle = element_text(size = 20),\n          axis.title = element_text(face = \"bold\"),\n          strip.text = element_text(face = \"bold\"),\n          strip.background = element_rect(fill = \"grey80\", color = NA),\n          legend.title = element_text(face = \"bold\"),\n          plot.title.position = \"plot\")\n}\nFirst lets generate some data from a normal distribution and set the random seed.\n#' lets start with some simulation\nset.seed(44)\nN &lt;- 1e4\nx &lt;- rnorm(N)\n\nx_perc &lt;- ntile(x, 100)"
  },
  {
    "objectID": "posts/percentiles/index.html#looking-at-marginal-distributions",
    "href": "posts/percentiles/index.html#looking-at-marginal-distributions",
    "title": "A few remarks on percentile scales",
    "section": "looking at marginal distributions",
    "text": "looking at marginal distributions\nLets start by looking at simple distributions. This one should be fairly obvious but I feel like it still gets forgotten way to often. How does a distribution of percentiles look like? Lets start with raw x and how it looks like:\n\n\nraw normal histogram\nggplot(data.frame(x), aes(x =x )) +\n  geom_histogram(fill = col_main[13]) +\n  labs(title = \"distribution of raw values\") +\n  my_theme()\n\n\n\n\n\n\n\n\n\nNice and friendly normal distribution. So how does a percentile distribution look like?\n\n\npercentile normal histogram\nggplot(data.frame(x_perc), aes(x =x_perc )) +\n  geom_histogram(bins = 100, fill = col_main[13]) +\n  labs(title = \"distribution of percentiles\") +\n  my_theme()\n\n\n\n\n\n\n\n\n\nIt’s perfectly flat! Percentiles will always look like this because, well… by definition they are percentages so the same number of observations into each percentile. We can change the original distribution but it won’t affect the percentile much. We can see it e.g. with exponential distribution:\n\n\nExponential histograms\nx_exp &lt;- rexp(N, 3)\nx_exp_perc &lt;- ntile(x_exp, 100)\n\nexp_raw &lt;- ggplot(data.frame(x_exp), aes(x =x_exp)) +\n  geom_histogram(fill = col_main[13]) +\n  labs(title = \"distribution of raw values\") +\n  my_theme()\n\nexp_perc &lt;- ggplot(data.frame(x_exp_perc), aes(x =x_exp_perc)) +\n  geom_histogram(bins = 100, fill = col_main[13]) +\n  labs(title = \"distribution of percentiles\") +\n  my_theme()\n\nexp_raw + exp_perc\n\n\n\n\n\n\n\n\n\nThis can get annoying sometimes e.g. when doctors act as if no one should be on the lowest percentiles (me and many of my friends have heard that plenty of times). Well, someone has to be on the lowest percentiles, that’s how percentiles work! And just as many people will be in the 1st percentile as there will be in the 50th percentile. This can be understandable from the perspective of individuals (no one wants to be the one having to deal with e.g. with kids with weight from the 1st percentile) but makes no sense once you look from a broader perspective."
  },
  {
    "objectID": "posts/percentiles/index.html#spacing-between-percentiles",
    "href": "posts/percentiles/index.html#spacing-between-percentiles",
    "title": "A few remarks on percentile scales",
    "section": "Spacing between percentiles",
    "text": "Spacing between percentiles\nOne thing that is often forgotten about the percentile scales is that there can be different spacings between various percentiles. Lets calculate the values for percentiles and then get differences between subsequent percentiles to look at this:\n\n\nspacing\nx_percentiles &lt;- quantile(x, probs = seq(.01, 1, .01))\n\nx_df &lt;- data.frame(x_percentiles) %&gt;%\n  mutate(perc_lag = lag(x_percentiles),\n         difference_1 = x_percentiles - perc_lag)\n\nx_df %&gt;%\n  drop_na() %&gt;%\n  ggplot(aes(x = 2:100, y = difference_1)) +\n  geom_point(color = col_main[13]) +\n  labs(x = NULL, y = \"difference\") +\n  my_theme()\n\n\n\n\n\n\n\n\n\nYou can see that the differences are quite large for the first few and last few percentiles and are pretty small for the rest. This is exactly what we would expect with a gaussian distribution of raw values.\nLets try to overlay the percentiles on the gaussian distribution we drew our data from\n\n\npercentile spacing\nas.data.frame(x) |&gt;\n  ggplot(aes(x)) +\n  geom_density(color = col_main[13], linewidth = 2) +\n  geom_vline(data = x_df, aes(xintercept = x_percentiles), color = col_main[15]) +\n  labs(title = \"Spacing of percentiles\", subtitle = \"Original distribution (thick blue line) has percentiles\\noverlayed as vertical lines (dark blue)\") +\n  my_theme()\n\n\n\n\n\n\n\n\n\nYou can see how much of the distribution falls into 1st, 2nd or 99th percentile and how little falls into a single percentile in the middle of the distribution. It’s actually fairly intuitive why this happens. The same number of people have to fall into each percentile and if there are few people at the tails of the distribution then we need to widen the range of the percentiles there to get enough people. The opposite is true for the peak of the distribution. There are a lot of people there so a slim sliver of the distribution is enough to get quite a few people into the percentile. Note that the 100th percentile is so far away because the quantile function records the higher boundary of the percentile rather than the middle so it has to end at the very far end of the distribution.\nOne very important consequence of this is that percentiles are pretty much ranks (see here for an good old text on the matter) and should be treated more as ordinal than interval scales which can be a bit unintuitive at first (see here for the perils of forgetting about that).\nThis also means that if some value increases over time from a very low percentile with a steady pace then we might expect first slow increases in percentiles, then rapid increases around the middle of the distribution and again slower increases as we are reaching the top. Lets try simulating that:\n\n\n1st simulation\nx_init &lt;- min(x) #start with the lowest value in our distribution\nperc_progress &lt;- c() #create a vector to store percentiles\nfor(i in 1:1000) { # max of 1000 steps\n  x_init &lt;- x_init + .1 #increase our value by .1\n  perc_value &lt;- min(x_percentiles[which(x_percentiles &gt; x_init)]) # get the percentile value\n  percentile &lt;- names(x_percentiles[which(x_percentiles == perc_value)]) # get the percentile name\n  perc_progress &lt;- c(perc_progress, percentile) # we want to stop if we get too close to max value and there are still iterations left (otherwise the min() function breaks)\n  if (x_init &gt;=(max(x) - .1)) {\n    break\n  }\n}\n\nperc_progress&lt;- as.numeric(str_extract(perc_progress, \"[0-9]+\"))\n\ndata.frame(perc_progress) %&gt;%\n  ggplot(aes(x = 1:length(perc_progress), y = perc_progress)) +\n  geom_line(color = col_main[12], linewidth = 2) +\n  labs(x = \"iteration\", y = \"percentile\") +\n  my_theme()\n\n\n\n\n\n\n\n\n\nExactly what we would expect! First the change in percentiles is slow, then it speeds up and slows down in the right half of the plot. It takes us a long time to get out of the lowest percentiles but once we do we quickly get to the 50th and start changing more slowly form there on.\n\nvariability in percentiles\nOne significant consequence of how differences between subsequent percentiles vary is how much variability in percentiles can we expect with the same amount of variability on the original scale depending on where we start.\nThis is a common thing when infants gain weight. They might be gaining weight by some amount plus some random variations (lots of reasons here - some things in the diet, baby pooped/peed before being weighed etc.). In low or high percentiles we might expect this random variation in how much they gain weight to matter little. However in the middle it will make the variation in percentiles seem bigger. Again lets simulate some random variation around our distribution of x with 3 starting places: low (5th), middle (50th) and high percentile (95th). We will run 100 simulations for each starting place and each simulation has 500 iterations.\n\n\n2nd simulation\nsimulate_variability &lt;- function(init_perc, sd_change, n_iter = 500) {\n  x_init &lt;- x_percentiles[init_perc] #start with the lowest value in our distribution\nperc_progress &lt;- c() #create a vector to store percentiles\nfor(i in 1:n_iter) { # max of 1000 steps\n  x_init &lt;- x_init + rnorm(1, mean = 0, sd = sd_change) #increase our value by .1\n  perc_value &lt;- min(x_percentiles[which(x_percentiles &gt; x_init)]) # get the percentile value\n  percentile &lt;- names(x_percentiles[which(x_percentiles == perc_value)]) # get the percentile name\n  perc_progress &lt;- c(perc_progress, percentile) # we want to stop if we get too close to max value and there are still iterations left (otherwise the min() function breaks)\n  if (x_init &gt;=(max(x) - .1) | x_init &lt;= (min(x) + .1)) {\n    break\n  }\n}\n  perc_progress&lt;- as.numeric(str_extract(perc_progress, \"[0-9]+\"))\n  return(perc_progress)\n}\n\n\n\nsimulate_growth &lt;- function(perc, n_iter = 500, n_runs = 100) {\n  df &lt;- data.frame()\n  for(i in 1:n_runs) {\n    prog&lt;- simulate_variability(perc, .02, n_iter)\n    df &lt;- rbind(df, prog)\n  }\n  colnames(df) &lt;- 1:n_iter\n  df$run &lt;- 1:n_runs\n  \n  df_long &lt;- df %&gt;%\n    pivot_longer(-c(run), names_to = \"iter\", values_to = \"percentile\") %&gt;%\n    mutate(condition = as.character(perc),\n           iter = as.numeric(iter))\n}\n\n\ndf_l &lt;- simulate_growth(5)\ndf_m &lt;- simulate_growth(50)\ndf_h &lt;- simulate_growth(95)\n\ndf_joined &lt;- bind_rows(df_l, df_m, df_h)\n\ndf_joined %&gt;%\n  ggplot(aes(x = as.numeric(iter), y = percentile, group = as.factor(run))) +\n  geom_line(alpha = .4, color = col_main[13]) +\n  facet_wrap(~condition) +\n  labs(title = \"Simulating variability in 5th, 50th and 95th percentile\",\n       x = \"iteration\") +\n  my_theme()\n\n\n\n\n\n\n\n\n\nYou can see a lot more variability in the middle panel than in the left or right ones even though the changes on the original scale come from the same distribution. We can also get the average range (difference between highest and lowest percentile on a given run):\n\n\nmean range of percentiles\ndf_joined %&gt;%\n  group_by(condition, run) %&gt;%\n  summarise(range = max(percentile) - min(percentile)) %&gt;%\n  summarise(mean_range = mean(range)) %&gt;%\n  gt::gt()\n\n\n\n\n\n\n\n\ncondition\nmean_range\n\n\n\n\n5\n6.64\n\n\n50\n25.13\n\n\n95\n6.40\n\n\n\n\n\n\n\nIn the above simulation we were in fact not creating any growth, just random variation from the original value (in order to simulate that we would need percentiles for each iteration) but assuming no strange growths that would not change the results a lot (rather than drawing a number from a distribution with mean 0 we would make the mean higher than 0 and still our expectation would be that a person in 50th percentile in time 1 should be on average in 50th percentile in time 2).\nThis means that when looking at percentiles e.g. weight gains of babies in low or high percentiles might seem much more stable than of those from the mid percentiles even if in fact they are very similar weight gains.\n\n\nSimulating from real data\nSome data on percentiles of baby weights are actually available online. This means we could check our simulation above with some real data that we can use as a basis for simulating growth. What we will do is:\n\nget the data that stores a number of percentiles of baby weight at months 0 to 24.\nget approximations of growth at various percentiles (5th, 50th and 95th)\nGet full percentile tables for each timepoint\nSimulate growth at those percentiles to see variability\n\nBelow is a plot of percentiles for male baby weights from birth to 24 months taken from CDC:\n\n\ncdc data\nbaby_w &lt;- read_delim(\"baby_weight.tsv\")\ncolnames(baby_w) &lt;- trimws(colnames(baby_w))\nbaby_w &lt;- baby_w %&gt;%\n  mutate(across(.cols = '3rd':'95th', as.numeric),\n         `months` = as.numeric(`months`))\n\n\nbaby_w %&gt;%\n  pivot_longer(cols = '3rd':'97th', values_to = \"weight\", names_to = \"percentile\") %&gt;%\n  mutate(percentile = factor(percentile, ordered = TRUE,\n                             levels = c(\"3rd\", \"5th\", \"10th\", \"25th\",\n                                        \"50th\", \"75th\", \"90th\", \"95th\", \"97th\"))) %&gt;%\n  ggplot(aes(x = months, y = weight, color = percentile, group = percentile)) +\n  geom_line(linewidth = 1.5) +\n  scale_color_manual(values = col_main[1:9]) +\n  labs(title = \"Weight percentiles for babies\\n0-24 months old\",\n       subtitle = \"Data from CDC\") +\n  my_theme()\n\n\n\n\n\n\n\n\n\nLets try to simulate that. We won’t go to any modelling really but rather use approxfun() to get an approximation of the growth function at a given percentile. Below is the code to get approximation for the 50th percentile. We will do the same at 5th and 95th\n\n\napproximating growth\n#growth function at 50th\n#get months and weights at 5th, 50th and 95th percentile\nx &lt;- baby_w$months\nweight_50 &lt;- baby_w$`50th`\nweight_5 &lt;- baby_w$`5th`\nweight_95 &lt;- baby_w$`95th`\n#make the approximation function\n\nfun_5 &lt;- approxfun(x = x, y = weight_5)\nfun_50 &lt;- approxfun(x = x, y = weight_50)\nfun_95 &lt;- approxfun(x = x, y = weight_95)\n\n\nWe can run a simple simulation to get some idea if they work ok. We will simulate growth based on our function plus a little random noise. We’ll check the 50th percentile function for brevity:\n\n\n50th percentile check\ndf_50 &lt;- data.frame()\nfor (i in 1:50) {\n  x_1 &lt;- fun_50(0)\n  x_1_results &lt;- c(x_1)\n  for (i in (1:25)) {\n  x_1 &lt;- x_1 + fun_50(x[i+1]) - fun_50(x[i]) + rnorm(1, 0, .05)\n  x_1_results &lt;- c(x_1_results, x_1)\n  }\n  df_50 &lt;- rbind(df_50, x_1_results)\n}\ncolnames(df_50) &lt;- x\n\ndf_50 %&gt;%\n  mutate(run = 1:50) %&gt;%\n  pivot_longer(-c(run), names_to = \"month\", values_to = \"weight\") %&gt;%\n  mutate(month = as.numeric(month)) %&gt;%\n  ggplot(aes(x = month, y = weight, group = run)) +\n  geom_line(alpha = .3, color = col_main[12]) +\n  geom_line(data = baby_w, aes(x = months, y = `50th`), color = col_main[14], linewidth = 1, inherit.aes = FALSE) +\n  labs(title = \"Simulating data for 50th percentile\",\n       subtitle = \"dark blue = actual data, light blue = simulated data\") +\n  my_theme()\n\n\n\n\n\n\n\n\n\nLooks pretty good! Now we will need full percentile tables since the cdc data provides only a handful of percentiles. I did that using an approximation for normal distributions.\n\n\nfull percentile grid\nget_mean_sd &lt;- function(perc_50, perc_75) {\n  m &lt;- perc_50\n  sd &lt;- (perc_75 - perc_50) / 0.6744898\n  result &lt;- c(m, sd)\n  return(result)\n}\n\nget_percentiles &lt;- function(time) {\n  perc_50 &lt;- as.vector(baby_w[time,6])\n  perc_75 &lt;- as.vector(baby_w[time,7])\n  msd_01 &lt;- as.vector(get_mean_sd(perc_50[[1]], perc_75[[1]]))\n\n\ns &lt;- rnorm(1e4, msd_01[1], msd_01[2])\n\npercentiles &lt;- quantile(s, seq(.01,1, .01))\nreturn(percentiles)\n}\n\npercentiles_df &lt;- data.frame(a = 1:100)\n\nfor(i in 1:26) {\n  p &lt;- get_percentiles(i)\n  percentiles_df[,i] &lt;- p\n}\ncnames &lt;- paste0(\"p_\", 1:26)\ncolnames(percentiles_df) &lt;- cnames\npercentiles_df$percentile &lt;- 1:100\n#the dataframe above has percentiles for each .5 month separately\n\n\nNow we can simulate baby growth and check against the percentile tables to see if for middle percentiles growth we will see more variability in percentiles. We will also store the raw weights so that we can look at it as well.\n\n\ncdc simulation\n#simulating the growth\n\nsimulate_from_cdc &lt;- function(fun, n_iter = 50, variability = .05) {\n  f &lt;- get(fun)\n  df_perc &lt;- data.frame()\n  df_raw &lt;- data.frame()\n  perc_origin &lt;- as.numeric(str_extract(fun, \"[0-9]+\"))\n  for (i in 1:n_iter) {\n    init &lt;- f(x[1])\n    raw &lt;- c(init)\n    results &lt;- c(perc_origin) #need to extract the percentile from the function name the percentile \n    for(i in 1:25) {\n      init &lt;- init + f(x[i+1]) - f(x[i]) + rnorm(1, 0, variability)\n      perc_value &lt;- min(percentiles_df[which(percentiles_df[,i+1] &gt; init), i+1]) # get the percentile value\n      perc &lt;- percentiles_df[which(percentiles_df[,i +1 ] == perc_value), \"percentile\"] # get the percentile name\n      results &lt;- c(results, perc)\n      raw &lt;- c(raw, init)\n    }\n    df_perc &lt;- rbind(df_perc, results)\n    df_raw &lt;- rbind(df_raw, raw)\n  }\n  \n  \n  colnames(df_perc) &lt;- x\n  df_perc$run &lt;- 1:n_iter\n  \n  df_perc_long &lt;- df_perc %&gt;%\n    pivot_longer(-c(run), names_to = \"month\", values_to = \"percentile\") %&gt;%\n    mutate(month = as.numeric(month),\n           condition = perc_origin) \n  \n  colnames(df_raw) &lt;- x\n  df_raw$run &lt;- 1:n_iter\n  \n  df_raw_long &lt;- df_raw %&gt;%\n    pivot_longer(-c(run), names_to = \"month\", values_to = \"weight\") %&gt;%\n    mutate(month = as.numeric(month),\n           condition = perc_origin)\n  df_perc_long$weight &lt;- df_raw_long$weight\n  return(df_perc_long)\n}\n\ndf_cdc_l &lt;- simulate_from_cdc(\"fun_5\")\ndf_cdc_m &lt;- simulate_from_cdc(\"fun_50\")\ndf_cdc_h &lt;- simulate_from_cdc(\"fun_95\")\n\ndf_cdc_joined &lt;- bind_rows(df_cdc_l, df_cdc_m, df_cdc_h)\n\ndf_cdc_joined %&gt;%\n  ggplot(aes(x = month, y = percentile, group = run)) +\n  geom_line(alpha = .3, color = col_main[16]) +\n  facet_wrap(~condition) +\n  labs(title = \"Simulating growth in percentiles\") +\n  my_theme()\n\n\n\n\n\n\n\n\n\nWe got very similar results to our earlier simulation! Middle panel show much larger variability in percentiles compared to the left and right ones. We can also get the average range in percentiles.\n\n\nmean ranges from cdc sim\ndf_cdc_joined %&gt;%\n  group_by(condition, run) %&gt;%\n  summarise(range = max(percentile) - min(percentile)) %&gt;%\n  summarise(mean_range = mean(range)) %&gt;%\n  gt::gt()\n\n\n\n\n\n\n\n\ncondition\nmean_range\n\n\n\n\n5\n5.76\n\n\n50\n11.94\n\n\n95\n3.04\n\n\n\n\n\n\n\nWe could compare this against actual growth in weight to see if there is more variability in 50th percentile (there should not be much):\n\n\ncomparing raw growth\ndf_cdc_joined %&gt;%\n  ggplot(aes(x = month, y = weight, group = run)) +\n  geom_line(alpha = .3, color = col_main[16]) +\n  facet_wrap(~condition) +\n  labs(title = \"raw weight growth in 5th, 50th and 95th percentile\") +\n  my_theme()\n\n\n\n\n\n\n\n\n\nIt does not seem like there is more variability in growth in the middle category when we look at .\n\n\nsome caveats and what is the point\nAll of the above of course depends not just on the data that we got from cdc but also on our assumed model of growth which is probably pretty simplistic. Can we assume constant random variability across percentiles and in time? I think the first one is easier but I don’t think it would undermine the point a lot if variability in time changed as long as it was the same across all percentiles.\nA more important point that is the drive home message is that you can’t forget about the original distribution of raw values when working with percentiles. If in the simulations above we were working with a different distribution then the variability in percentiles would look different. For example for a bimodal distribution we would see the exact opposite from what happens with a normal distribution - the greater variability would be at lowest and highest percentiles.\nMaybe if I have the time and some data I will try to make some longitudinal ordinal models (like a Markov model or some multilevel ordinal maybe) to expand on this (something like described by Frank Harrell here)."
  }
]